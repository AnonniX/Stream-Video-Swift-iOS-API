//
// WSEvent.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** The discriminator object for all websocket events, you should use this to map event payloads to their own type */
enum WSEvent: Codable, JSONEncodable, Hashable {
    case typeBlockedUserEvent(BlockedUserEvent)
    case typeCallAcceptedEvent(CallAcceptedEvent)
    case typeCallCancelledEvent(CallCancelledEvent)
    case typeCallCreatedEvent(CallCreatedEvent)
    case typeCallEndedEvent(CallEndedEvent)
    case typeCallReactionEvent(CallReactionEvent)
    case typeCallRecordingStartedEvent(CallRecordingStartedEvent)
    case typeCallRecordingStoppedEvent(CallRecordingStoppedEvent)
    case typeCallRejectedEvent(CallRejectedEvent)
    case typeCallUpdatedEvent(CallUpdatedEvent)
    case typeCustomVideoEvent(CustomVideoEvent)
    case typeHealthCheckEvent(HealthCheckEvent)
    case typePermissionRequestEvent(PermissionRequestEvent)
    case typeUnblockedUserEvent(UnblockedUserEvent)
    case typeUpdatedCallPermissionsEvent(UpdatedCallPermissionsEvent)

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .typeBlockedUserEvent(let value):
            try container.encode(value)
        case .typeCallAcceptedEvent(let value):
            try container.encode(value)
        case .typeCallCancelledEvent(let value):
            try container.encode(value)
        case .typeCallCreatedEvent(let value):
            try container.encode(value)
        case .typeCallEndedEvent(let value):
            try container.encode(value)
        case .typeCallReactionEvent(let value):
            try container.encode(value)
        case .typeCallRecordingStartedEvent(let value):
            try container.encode(value)
        case .typeCallRecordingStoppedEvent(let value):
            try container.encode(value)
        case .typeCallRejectedEvent(let value):
            try container.encode(value)
        case .typeCallUpdatedEvent(let value):
            try container.encode(value)
        case .typeCustomVideoEvent(let value):
            try container.encode(value)
        case .typeHealthCheckEvent(let value):
            try container.encode(value)
        case .typePermissionRequestEvent(let value):
            try container.encode(value)
        case .typeUnblockedUserEvent(let value):
            try container.encode(value)
        case .typeUpdatedCallPermissionsEvent(let value):
            try container.encode(value)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(BlockedUserEvent.self) {
            self = .typeBlockedUserEvent(value)
        } else if let value = try? container.decode(CallAcceptedEvent.self) {
            self = .typeCallAcceptedEvent(value)
        } else if let value = try? container.decode(CallCancelledEvent.self) {
            self = .typeCallCancelledEvent(value)
        } else if let value = try? container.decode(CallCreatedEvent.self) {
            self = .typeCallCreatedEvent(value)
        } else if let value = try? container.decode(CallEndedEvent.self) {
            self = .typeCallEndedEvent(value)
        } else if let value = try? container.decode(CallReactionEvent.self) {
            self = .typeCallReactionEvent(value)
        } else if let value = try? container.decode(CallRecordingStartedEvent.self) {
            self = .typeCallRecordingStartedEvent(value)
        } else if let value = try? container.decode(CallRecordingStoppedEvent.self) {
            self = .typeCallRecordingStoppedEvent(value)
        } else if let value = try? container.decode(CallRejectedEvent.self) {
            self = .typeCallRejectedEvent(value)
        } else if let value = try? container.decode(CallUpdatedEvent.self) {
            self = .typeCallUpdatedEvent(value)
        } else if let value = try? container.decode(CustomVideoEvent.self) {
            self = .typeCustomVideoEvent(value)
        } else if let value = try? container.decode(HealthCheckEvent.self) {
            self = .typeHealthCheckEvent(value)
        } else if let value = try? container.decode(PermissionRequestEvent.self) {
            self = .typePermissionRequestEvent(value)
        } else if let value = try? container.decode(UnblockedUserEvent.self) {
            self = .typeUnblockedUserEvent(value)
        } else if let value = try? container.decode(UpdatedCallPermissionsEvent.self) {
            self = .typeUpdatedCallPermissionsEvent(value)
        } else {
            throw DecodingError.typeMismatch(Self.Type.self, .init(codingPath: decoder.codingPath, debugDescription: "Unable to decode instance of WSEvent"))
        }
    }
}

