//
// Copyright Â© 2022 Stream.io Inc. All rights reserved.
//

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

struct Stream_Video_Sfu_Event_SfuEvent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var eventPayload: Stream_Video_Sfu_Event_SfuEvent.OneOf_EventPayload?

    var subscriberOffer: Stream_Video_Sfu_Event_SubscriberOffer {
        get {
            if case let .subscriberOffer(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_SubscriberOffer()
        }
        set { eventPayload = .subscriberOffer(newValue) }
    }

    var connectionQualityChanged: Stream_Video_Sfu_Event_ConnectionQualityChanged {
        get {
            if case let .connectionQualityChanged(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_ConnectionQualityChanged()
        }
        set { eventPayload = .connectionQualityChanged(newValue) }
    }

    var audioLevelChanged: Stream_Video_Sfu_Event_AudioLevelChanged {
        get {
            if case let .audioLevelChanged(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_AudioLevelChanged()
        }
        set { eventPayload = .audioLevelChanged(newValue) }
    }

    var subscriberCandidate: Stream_Video_Sfu_Event_ICECandidateTrickle {
        get {
            if case let .subscriberCandidate(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_ICECandidateTrickle()
        }
        set { eventPayload = .subscriberCandidate(newValue) }
    }

    var publisherCandidate: Stream_Video_Sfu_Event_ICECandidateTrickle {
        get {
            if case let .publisherCandidate(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_ICECandidateTrickle()
        }
        set { eventPayload = .publisherCandidate(newValue) }
    }

    var changePublishQuality: Stream_Video_Sfu_Event_ChangePublishQuality {
        get {
            if case let .changePublishQuality(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_ChangePublishQuality()
        }
        set { eventPayload = .changePublishQuality(newValue) }
    }

    var localDeviceChange: Stream_Video_Sfu_Event_LocalDeviceChange {
        get {
            if case let .localDeviceChange(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_LocalDeviceChange()
        }
        set { eventPayload = .localDeviceChange(newValue) }
    }

    var muteStateChanged: Stream_Video_Sfu_Event_MuteStateChanged {
        get {
            if case let .muteStateChanged(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_MuteStateChanged()
        }
        set { eventPayload = .muteStateChanged(newValue) }
    }

    var videoQualityChanged: Stream_Video_Sfu_Event_VideoQualityChanged {
        get {
            if case let .videoQualityChanged(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_VideoQualityChanged()
        }
        set { eventPayload = .videoQualityChanged(newValue) }
    }

    var participantJoined: Stream_Video_Sfu_Event_ParticipantJoined {
        get {
            if case let .participantJoined(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_ParticipantJoined()
        }
        set { eventPayload = .participantJoined(newValue) }
    }

    var participantLeft: Stream_Video_Sfu_Event_ParticipantLeft {
        get {
            if case let .participantLeft(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_ParticipantLeft()
        }
        set { eventPayload = .participantLeft(newValue) }
    }

    var dominantSpeakerChanged: Stream_Video_Sfu_Event_DominantSpeakerChanged {
        get {
            if case let .dominantSpeakerChanged(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_DominantSpeakerChanged()
        }
        set { eventPayload = .dominantSpeakerChanged(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_EventPayload: Equatable {
        case subscriberOffer(Stream_Video_Sfu_Event_SubscriberOffer)
        case connectionQualityChanged(Stream_Video_Sfu_Event_ConnectionQualityChanged)
        case audioLevelChanged(Stream_Video_Sfu_Event_AudioLevelChanged)
        case subscriberCandidate(Stream_Video_Sfu_Event_ICECandidateTrickle)
        case publisherCandidate(Stream_Video_Sfu_Event_ICECandidateTrickle)
        case changePublishQuality(Stream_Video_Sfu_Event_ChangePublishQuality)
        case localDeviceChange(Stream_Video_Sfu_Event_LocalDeviceChange)
        case muteStateChanged(Stream_Video_Sfu_Event_MuteStateChanged)
        case videoQualityChanged(Stream_Video_Sfu_Event_VideoQualityChanged)
        case participantJoined(Stream_Video_Sfu_Event_ParticipantJoined)
        case participantLeft(Stream_Video_Sfu_Event_ParticipantLeft)
        case dominantSpeakerChanged(Stream_Video_Sfu_Event_DominantSpeakerChanged)

        #if !swift(>=4.1)
        static func == (
            lhs: Stream_Video_Sfu_Event_SfuEvent.OneOf_EventPayload,
            rhs: Stream_Video_Sfu_Event_SfuEvent.OneOf_EventPayload
        ) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.subscriberOffer, .subscriberOffer): return {
                    guard case let .subscriberOffer(l) = lhs, case let .subscriberOffer(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.connectionQualityChanged, .connectionQualityChanged): return {
                    guard case let .connectionQualityChanged(l) = lhs,
                          case let .connectionQualityChanged(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.audioLevelChanged, .audioLevelChanged): return {
                    guard case let .audioLevelChanged(l) = lhs, case let .audioLevelChanged(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.subscriberCandidate, .subscriberCandidate): return {
                    guard case let .subscriberCandidate(l) = lhs,
                          case let .subscriberCandidate(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.publisherCandidate, .publisherCandidate): return {
                    guard case let .publisherCandidate(l) = lhs,
                          case let .publisherCandidate(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.changePublishQuality, .changePublishQuality): return {
                    guard case let .changePublishQuality(l) = lhs,
                          case let .changePublishQuality(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.localDeviceChange, .localDeviceChange): return {
                    guard case let .localDeviceChange(l) = lhs, case let .localDeviceChange(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.muteStateChanged, .muteStateChanged): return {
                    guard case let .muteStateChanged(l) = lhs, case let .muteStateChanged(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.videoQualityChanged, .videoQualityChanged): return {
                    guard case let .videoQualityChanged(l) = lhs,
                          case let .videoQualityChanged(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.participantJoined, .participantJoined): return {
                    guard case let .participantJoined(l) = lhs, case let .participantJoined(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.participantLeft, .participantLeft): return {
                    guard case let .participantLeft(l) = lhs, case let .participantLeft(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.dominantSpeakerChanged, .dominantSpeakerChanged): return {
                    guard case let .dominantSpeakerChanged(l) = lhs,
                          case let .dominantSpeakerChanged(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            default: return false
            }
        }
        #endif
    }

    init() {}
}

/// ParticipantJoined is fired when a user joins a call
struct Stream_Video_Sfu_Event_ParticipantJoined {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Sfu_Models_Call {
        get { _call ?? Stream_Video_Sfu_Models_Call() }
        set { _call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { self._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _call = nil }

    var participant: Stream_Video_Sfu_Models_Participant {
        get { _participant ?? Stream_Video_Sfu_Models_Participant() }
        set { _participant = newValue }
    }

    /// Returns true if `participant` has been explicitly set.
    var hasParticipant: Bool { self._participant != nil }
    /// Clears the value of `participant`. Subsequent reads from it will return its default value.
    mutating func clearParticipant() { _participant = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _call: Stream_Video_Sfu_Models_Call?
    fileprivate var _participant: Stream_Video_Sfu_Models_Participant?
}

/// ParticipantJoined is fired when a user leaves a call
struct Stream_Video_Sfu_Event_ParticipantLeft {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Sfu_Models_Call {
        get { _call ?? Stream_Video_Sfu_Models_Call() }
        set { _call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { self._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _call = nil }

    var participant: Stream_Video_Sfu_Models_Participant {
        get { _participant ?? Stream_Video_Sfu_Models_Participant() }
        set { _participant = newValue }
    }

    /// Returns true if `participant` has been explicitly set.
    var hasParticipant: Bool { self._participant != nil }
    /// Clears the value of `participant`. Subsequent reads from it will return its default value.
    mutating func clearParticipant() { _participant = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _call: Stream_Video_Sfu_Models_Call?
    fileprivate var _participant: Stream_Video_Sfu_Models_Participant?
}

struct Stream_Video_Sfu_Event_MuteStateChanged {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: String = String()

    var audioMuted: Bool = false

    var videoMuted: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_VideoQualityChanged {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var streamQualities: [Stream_Video_Sfu_Models_StreamQuality] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// SubscriberOffer is sent when the SFU adds tracks to a subscription
/// this usually happens when a user joins a call and starts sending video
struct Stream_Video_Sfu_Event_SubscriberOffer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sdp: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_LocalDeviceChange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// ICECandidateTrickle is about the ICE nonsense stuff
struct Stream_Video_Sfu_Event_ICECandidateTrickle {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var candidate: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// ConnectionQuality is sent to inform about connection quality changes
/// eg. thierry's connection is not good -> render a red icon Zoom style
struct Stream_Video_Sfu_Event_ConnectionQualityChanged {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: String = String()

    var connectionQuality: Stream_Video_Sfu_Models_ConnectionQuality = .bad

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// DominantSpeakerChanged is sent by the SFU to notify when there is a new dominant speaker in the call
struct Stream_Video_Sfu_Event_DominantSpeakerChanged {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// AudioLevelChanged is sent by the SFU to notify about audio levels by user
struct Stream_Video_Sfu_Event_AudioLevelChanged {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var audioLevels: [Stream_Video_Sfu_Event_AudioLevel] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_AudioLevel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: String = String()

    /// 0.0 means complete silence, 1.0 loudest
    var level: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_AudioLayerSetting {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_AudioMediaRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var channelCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_AudioSender {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mediaRequest: Stream_Video_Sfu_Event_AudioMediaRequest {
        get { _mediaRequest ?? Stream_Video_Sfu_Event_AudioMediaRequest() }
        set { _mediaRequest = newValue }
    }

    /// Returns true if `mediaRequest` has been explicitly set.
    var hasMediaRequest: Bool { self._mediaRequest != nil }
    /// Clears the value of `mediaRequest`. Subsequent reads from it will return its default value.
    mutating func clearMediaRequest() { _mediaRequest = nil }

    var codec: Stream_Video_Sfu_Models_Codec {
        get { _codec ?? Stream_Video_Sfu_Models_Codec() }
        set { _codec = newValue }
    }

    /// Returns true if `codec` has been explicitly set.
    var hasCodec: Bool { self._codec != nil }
    /// Clears the value of `codec`. Subsequent reads from it will return its default value.
    mutating func clearCodec() { _codec = nil }

    var layers: [Stream_Video_Sfu_Event_AudioLayerSetting] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _mediaRequest: Stream_Video_Sfu_Event_AudioMediaRequest?
    fileprivate var _codec: Stream_Video_Sfu_Models_Codec?
}

struct Stream_Video_Sfu_Event_VideoMediaRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var idealHeight: Int32 = 0

    var idealWidth: Int32 = 0

    var idealFrameRate: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_VideoLayerSetting {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var active: Bool = false

    var maxBitrate: Int32 = 0

    var scaleResolutionDownBy: Float = 0

    var priority: Stream_Video_Sfu_Event_VideoLayerSetting.Priority = .high

    var codec: Stream_Video_Sfu_Models_Codec {
        get { _codec ?? Stream_Video_Sfu_Models_Codec() }
        set { _codec = newValue }
    }

    /// Returns true if `codec` has been explicitly set.
    var hasCodec: Bool { self._codec != nil }
    /// Clears the value of `codec`. Subsequent reads from it will return its default value.
    mutating func clearCodec() { _codec = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Priority: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case high // = 0
        case low // = 1
        case medium // = 2
        case veryLow // = 3
        case UNRECOGNIZED(Int)

        init() {
            self = .high
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .high
            case 1: self = .low
            case 2: self = .medium
            case 3: self = .veryLow
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .high: return 0
            case .low: return 1
            case .medium: return 2
            case .veryLow: return 3
            case let .UNRECOGNIZED(i): return i
            }
        }
    }

    init() {}

    fileprivate var _codec: Stream_Video_Sfu_Models_Codec?
}

#if swift(>=4.2)

extension Stream_Video_Sfu_Event_VideoLayerSetting.Priority: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Stream_Video_Sfu_Event_VideoLayerSetting.Priority] = [
        .high,
        .low,
        .medium,
        .veryLow
    ]
}

#endif // swift(>=4.2)

struct Stream_Video_Sfu_Event_VideoSender {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mediaRequest: Stream_Video_Sfu_Event_VideoMediaRequest {
        get { _mediaRequest ?? Stream_Video_Sfu_Event_VideoMediaRequest() }
        set { _mediaRequest = newValue }
    }

    /// Returns true if `mediaRequest` has been explicitly set.
    var hasMediaRequest: Bool { self._mediaRequest != nil }
    /// Clears the value of `mediaRequest`. Subsequent reads from it will return its default value.
    mutating func clearMediaRequest() { _mediaRequest = nil }

    var codec: Stream_Video_Sfu_Models_Codec {
        get { _codec ?? Stream_Video_Sfu_Models_Codec() }
        set { _codec = newValue }
    }

    /// Returns true if `codec` has been explicitly set.
    var hasCodec: Bool { self._codec != nil }
    /// Clears the value of `codec`. Subsequent reads from it will return its default value.
    mutating func clearCodec() { _codec = nil }

    var layers: [Stream_Video_Sfu_Event_VideoLayerSetting] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _mediaRequest: Stream_Video_Sfu_Event_VideoMediaRequest?
    fileprivate var _codec: Stream_Video_Sfu_Models_Codec?
}

/// sent to users when they need to change the quality of their video
struct Stream_Video_Sfu_Event_ChangePublishQuality {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var audioSender: [Stream_Video_Sfu_Event_AudioSender] = []

    var videoSender: [Stream_Video_Sfu_Event_VideoSender] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stream_Video_Sfu_Event_SfuEvent: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_SfuEvent.OneOf_EventPayload: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ParticipantJoined: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ParticipantLeft: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_MuteStateChanged: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoQualityChanged: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_SubscriberOffer: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_LocalDeviceChange: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ICECandidateTrickle: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ConnectionQualityChanged: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_DominantSpeakerChanged: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioLevelChanged: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioLevel: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioLayerSetting: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioMediaRequest: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioSender: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoMediaRequest: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoLayerSetting: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoLayerSetting.Priority: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoSender: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ChangePublishQuality: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "stream.video.sfu.event"

extension Stream_Video_Sfu_Event_SfuEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SfuEvent"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "subscriber_offer"),
        2: .standard(proto: "connection_quality_changed"),
        3: .standard(proto: "audio_level_changed"),
        4: .standard(proto: "subscriber_candidate"),
        5: .standard(proto: "publisher_candidate"),
        6: .standard(proto: "change_publish_quality"),
        7: .standard(proto: "local_device_change"),
        8: .standard(proto: "mute_state_changed"),
        9: .standard(proto: "video_quality_changed"),
        10: .standard(proto: "participant_joined"),
        11: .standard(proto: "participant_left"),
        12: .standard(proto: "dominant_speaker_changed")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: Stream_Video_Sfu_Event_SubscriberOffer?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .subscriberOffer(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .subscriberOffer(v)
                    }
                }()
            case 2: try {
                    var v: Stream_Video_Sfu_Event_ConnectionQualityChanged?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .connectionQualityChanged(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .connectionQualityChanged(v)
                    }
                }()
            case 3: try {
                    var v: Stream_Video_Sfu_Event_AudioLevelChanged?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .audioLevelChanged(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .audioLevelChanged(v)
                    }
                }()
            case 4: try {
                    var v: Stream_Video_Sfu_Event_ICECandidateTrickle?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .subscriberCandidate(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .subscriberCandidate(v)
                    }
                }()
            case 5: try {
                    var v: Stream_Video_Sfu_Event_ICECandidateTrickle?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .publisherCandidate(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .publisherCandidate(v)
                    }
                }()
            case 6: try {
                    var v: Stream_Video_Sfu_Event_ChangePublishQuality?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .changePublishQuality(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .changePublishQuality(v)
                    }
                }()
            case 7: try {
                    var v: Stream_Video_Sfu_Event_LocalDeviceChange?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .localDeviceChange(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .localDeviceChange(v)
                    }
                }()
            case 8: try {
                    var v: Stream_Video_Sfu_Event_MuteStateChanged?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .muteStateChanged(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .muteStateChanged(v)
                    }
                }()
            case 9: try {
                    var v: Stream_Video_Sfu_Event_VideoQualityChanged?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .videoQualityChanged(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .videoQualityChanged(v)
                    }
                }()
            case 10: try {
                    var v: Stream_Video_Sfu_Event_ParticipantJoined?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .participantJoined(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .participantJoined(v)
                    }
                }()
            case 11: try {
                    var v: Stream_Video_Sfu_Event_ParticipantLeft?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .participantLeft(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .participantLeft(v)
                    }
                }()
            case 12: try {
                    var v: Stream_Video_Sfu_Event_DominantSpeakerChanged?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .dominantSpeakerChanged(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .dominantSpeakerChanged(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch eventPayload {
        case .subscriberOffer?: try {
                guard case let .subscriberOffer(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .connectionQualityChanged?: try {
                guard case let .connectionQualityChanged(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .audioLevelChanged?: try {
                guard case let .audioLevelChanged(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .subscriberCandidate?: try {
                guard case let .subscriberCandidate(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .publisherCandidate?: try {
                guard case let .publisherCandidate(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case .changePublishQuality?: try {
                guard case let .changePublishQuality(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            }()
        case .localDeviceChange?: try {
                guard case let .localDeviceChange(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            }()
        case .muteStateChanged?: try {
                guard case let .muteStateChanged(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
            }()
        case .videoQualityChanged?: try {
                guard case let .videoQualityChanged(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
            }()
        case .participantJoined?: try {
                guard case let .participantJoined(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
            }()
        case .participantLeft?: try {
                guard case let .participantLeft(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
            }()
        case .dominantSpeakerChanged?: try {
                guard case let .dominantSpeakerChanged(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_SfuEvent, rhs: Stream_Video_Sfu_Event_SfuEvent) -> Bool {
        if lhs.eventPayload != rhs.eventPayload { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_ParticipantJoined: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ParticipantJoined"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call"),
        2: .same(proto: "participant")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._participant) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._call {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._participant {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_ParticipantJoined, rhs: Stream_Video_Sfu_Event_ParticipantJoined) -> Bool {
        if lhs._call != rhs._call { return false }
        if lhs._participant != rhs._participant { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_ParticipantLeft: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ParticipantLeft"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call"),
        2: .same(proto: "participant")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._participant) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._call {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._participant {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_ParticipantLeft, rhs: Stream_Video_Sfu_Event_ParticipantLeft) -> Bool {
        if lhs._call != rhs._call { return false }
        if lhs._participant != rhs._participant { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_MuteStateChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".MuteStateChanged"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_id"),
        2: .standard(proto: "audio_muted"),
        3: .standard(proto: "video_muted")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.audioMuted) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.videoMuted) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 1)
        }
        if audioMuted != false {
            try visitor.visitSingularBoolField(value: audioMuted, fieldNumber: 2)
        }
        if videoMuted != false {
            try visitor.visitSingularBoolField(value: videoMuted, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_MuteStateChanged, rhs: Stream_Video_Sfu_Event_MuteStateChanged) -> Bool {
        if lhs.userID != rhs.userID { return false }
        if lhs.audioMuted != rhs.audioMuted { return false }
        if lhs.videoMuted != rhs.videoMuted { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_VideoQualityChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".VideoQualityChanged"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "stream_qualities")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.streamQualities) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !streamQualities.isEmpty {
            try visitor.visitRepeatedMessageField(value: streamQualities, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_VideoQualityChanged, rhs: Stream_Video_Sfu_Event_VideoQualityChanged) -> Bool {
        if lhs.streamQualities != rhs.streamQualities { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_SubscriberOffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SubscriberOffer"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "sdp")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.sdp) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !sdp.isEmpty {
            try visitor.visitSingularStringField(value: sdp, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_SubscriberOffer, rhs: Stream_Video_Sfu_Event_SubscriberOffer) -> Bool {
        if lhs.sdp != rhs.sdp { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_LocalDeviceChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".LocalDeviceChange"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_LocalDeviceChange, rhs: Stream_Video_Sfu_Event_LocalDeviceChange) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_ICECandidateTrickle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ICECandidateTrickle"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "candidate")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.candidate) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !candidate.isEmpty {
            try visitor.visitSingularStringField(value: candidate, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_ICECandidateTrickle, rhs: Stream_Video_Sfu_Event_ICECandidateTrickle) -> Bool {
        if lhs.candidate != rhs.candidate { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_ConnectionQualityChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ConnectionQualityChanged"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_id"),
        2: .standard(proto: "connection_quality")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            case 2: try { try decoder.decodeSingularEnumField(value: &self.connectionQuality) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 1)
        }
        if connectionQuality != .bad {
            try visitor.visitSingularEnumField(value: connectionQuality, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Sfu_Event_ConnectionQualityChanged,
        rhs: Stream_Video_Sfu_Event_ConnectionQualityChanged
    ) -> Bool {
        if lhs.userID != rhs.userID { return false }
        if lhs.connectionQuality != rhs.connectionQuality { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_DominantSpeakerChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DominantSpeakerChanged"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Sfu_Event_DominantSpeakerChanged,
        rhs: Stream_Video_Sfu_Event_DominantSpeakerChanged
    ) -> Bool {
        if lhs.userID != rhs.userID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_AudioLevelChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AudioLevelChanged"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "audio_levels")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.audioLevels) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !audioLevels.isEmpty {
            try visitor.visitRepeatedMessageField(value: audioLevels, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_AudioLevelChanged, rhs: Stream_Video_Sfu_Event_AudioLevelChanged) -> Bool {
        if lhs.audioLevels != rhs.audioLevels { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_AudioLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AudioLevel"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_id"),
        2: .same(proto: "level")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            case 2: try { try decoder.decodeSingularFloatField(value: &self.level) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 1)
        }
        if level != 0 {
            try visitor.visitSingularFloatField(value: level, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_AudioLevel, rhs: Stream_Video_Sfu_Event_AudioLevel) -> Bool {
        if lhs.userID != rhs.userID { return false }
        if lhs.level != rhs.level { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_AudioLayerSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AudioLayerSetting"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_AudioLayerSetting, rhs: Stream_Video_Sfu_Event_AudioLayerSetting) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_AudioMediaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AudioMediaRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "channelCount")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularInt32Field(value: &self.channelCount) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if channelCount != 0 {
            try visitor.visitSingularInt32Field(value: channelCount, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_AudioMediaRequest, rhs: Stream_Video_Sfu_Event_AudioMediaRequest) -> Bool {
        if lhs.channelCount != rhs.channelCount { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_AudioSender: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AudioSender"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "mediaRequest"),
        2: .same(proto: "codec"),
        3: .same(proto: "layers")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._mediaRequest) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._codec) }()
            case 3: try { try decoder.decodeRepeatedMessageField(value: &self.layers) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._mediaRequest {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._codec {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if !layers.isEmpty {
            try visitor.visitRepeatedMessageField(value: layers, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_AudioSender, rhs: Stream_Video_Sfu_Event_AudioSender) -> Bool {
        if lhs._mediaRequest != rhs._mediaRequest { return false }
        if lhs._codec != rhs._codec { return false }
        if lhs.layers != rhs.layers { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_VideoMediaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".VideoMediaRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "idealHeight"),
        2: .same(proto: "idealWidth"),
        3: .same(proto: "idealFrameRate")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularInt32Field(value: &self.idealHeight) }()
            case 2: try { try decoder.decodeSingularInt32Field(value: &self.idealWidth) }()
            case 3: try { try decoder.decodeSingularInt32Field(value: &self.idealFrameRate) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if idealHeight != 0 {
            try visitor.visitSingularInt32Field(value: idealHeight, fieldNumber: 1)
        }
        if idealWidth != 0 {
            try visitor.visitSingularInt32Field(value: idealWidth, fieldNumber: 2)
        }
        if idealFrameRate != 0 {
            try visitor.visitSingularInt32Field(value: idealFrameRate, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_VideoMediaRequest, rhs: Stream_Video_Sfu_Event_VideoMediaRequest) -> Bool {
        if lhs.idealHeight != rhs.idealHeight { return false }
        if lhs.idealWidth != rhs.idealWidth { return false }
        if lhs.idealFrameRate != rhs.idealFrameRate { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_VideoLayerSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".VideoLayerSetting"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "active"),
        3: .same(proto: "maxBitrate"),
        4: .same(proto: "scaleResolutionDownBy"),
        5: .same(proto: "priority"),
        6: .same(proto: "codec")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.active) }()
            case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxBitrate) }()
            case 4: try { try decoder.decodeSingularFloatField(value: &self.scaleResolutionDownBy) }()
            case 5: try { try decoder.decodeSingularEnumField(value: &self.priority) }()
            case 6: try { try decoder.decodeSingularMessageField(value: &self._codec) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if active != false {
            try visitor.visitSingularBoolField(value: active, fieldNumber: 2)
        }
        if maxBitrate != 0 {
            try visitor.visitSingularInt32Field(value: maxBitrate, fieldNumber: 3)
        }
        if scaleResolutionDownBy != 0 {
            try visitor.visitSingularFloatField(value: scaleResolutionDownBy, fieldNumber: 4)
        }
        if priority != .high {
            try visitor.visitSingularEnumField(value: priority, fieldNumber: 5)
        }
        try { if let v = self._codec {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_VideoLayerSetting, rhs: Stream_Video_Sfu_Event_VideoLayerSetting) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.active != rhs.active { return false }
        if lhs.maxBitrate != rhs.maxBitrate { return false }
        if lhs.scaleResolutionDownBy != rhs.scaleResolutionDownBy { return false }
        if lhs.priority != rhs.priority { return false }
        if lhs._codec != rhs._codec { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_VideoLayerSetting.Priority: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "HIGH"),
        1: .same(proto: "LOW"),
        2: .same(proto: "MEDIUM"),
        3: .same(proto: "VERY_LOW")
    ]
}

extension Stream_Video_Sfu_Event_VideoSender: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".VideoSender"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "mediaRequest"),
        2: .same(proto: "codec"),
        3: .same(proto: "layers")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._mediaRequest) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._codec) }()
            case 3: try { try decoder.decodeRepeatedMessageField(value: &self.layers) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._mediaRequest {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._codec {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if !layers.isEmpty {
            try visitor.visitRepeatedMessageField(value: layers, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_VideoSender, rhs: Stream_Video_Sfu_Event_VideoSender) -> Bool {
        if lhs._mediaRequest != rhs._mediaRequest { return false }
        if lhs._codec != rhs._codec { return false }
        if lhs.layers != rhs.layers { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_ChangePublishQuality: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ChangePublishQuality"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "audio_sender"),
        2: .standard(proto: "video_sender")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.audioSender) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.videoSender) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !audioSender.isEmpty {
            try visitor.visitRepeatedMessageField(value: audioSender, fieldNumber: 1)
        }
        if !videoSender.isEmpty {
            try visitor.visitRepeatedMessageField(value: videoSender, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_ChangePublishQuality, rhs: Stream_Video_Sfu_Event_ChangePublishQuality) -> Bool {
        if lhs.audioSender != rhs.audioSender { return false }
        if lhs.videoSender != rhs.videoSender { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
