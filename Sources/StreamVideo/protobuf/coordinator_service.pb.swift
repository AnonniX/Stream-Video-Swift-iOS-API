//
// Copyright Â© 2022 Stream.io Inc. All rights reserved.
//

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

enum Stream_Video_CallStatEventType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case audioFrozenUnspecified // = 0
    case audioDelay // = 1
    case videoFrozen // = 2
    case videoDelay // = 3
    case videoNotOptimal // = 4
    case UNRECOGNIZED(Int)

    init() {
        self = .audioFrozenUnspecified
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .audioFrozenUnspecified
        case 1: self = .audioDelay
        case 2: self = .videoFrozen
        case 3: self = .videoDelay
        case 4: self = .videoNotOptimal
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .audioFrozenUnspecified: return 0
        case .audioDelay: return 1
        case .videoFrozen: return 2
        case .videoDelay: return 3
        case .videoNotOptimal: return 4
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

extension Stream_Video_CallStatEventType: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Stream_Video_CallStatEventType] = [
        .audioFrozenUnspecified,
        .audioDelay,
        .videoFrozen,
        .videoDelay,
        .videoNotOptimal
    ]
}

#endif // swift(>=4.2)

enum Stream_Video_UserEventType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case audioMutedUnspecified // = 0
    case audioUnmuted // = 1
    case videoStarted // = 2
    case videoStopped // = 3
    case UNRECOGNIZED(Int)

    init() {
        self = .audioMutedUnspecified
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .audioMutedUnspecified
        case 1: self = .audioUnmuted
        case 2: self = .videoStarted
        case 3: self = .videoStopped
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .audioMutedUnspecified: return 0
        case .audioUnmuted: return 1
        case .videoStarted: return 2
        case .videoStopped: return 3
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

extension Stream_Video_UserEventType: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Stream_Video_UserEventType] = [
        .audioMutedUnspecified,
        .audioUnmuted,
        .videoStarted,
        .videoStopped
    ]
}

#endif // swift(>=4.2)

struct Stream_Video_AddPushProviderRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var settings: Stream_Video_PushProvider {
        get { _settings ?? Stream_Video_PushProvider() }
        set { _settings = newValue }
    }

    /// Returns true if `settings` has been explicitly set.
    var hasSettings: Bool { self._settings != nil }
    /// Clears the value of `settings`. Subsequent reads from it will return its default value.
    mutating func clearSettings() { _settings = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _settings: Stream_Video_PushProvider?
}

struct Stream_Video_UpdatePushProviderRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var settings: Stream_Video_PushProvider {
        get { _settings ?? Stream_Video_PushProvider() }
        set { _settings = newValue }
    }

    /// Returns true if `settings` has been explicitly set.
    var hasSettings: Bool { self._settings != nil }
    /// Clears the value of `settings`. Subsequent reads from it will return its default value.
    mutating func clearSettings() { _settings = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _settings: Stream_Video_PushProvider?
}

struct Stream_Video_DeletePushProviderRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_UpdateAppSettingsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the webhook URL
    var webhookURL: SwiftProtobuf.Google_Protobuf_StringValue {
        get { _webhookURL ?? SwiftProtobuf.Google_Protobuf_StringValue() }
        set { _webhookURL = newValue }
    }

    /// Returns true if `webhookURL` has been explicitly set.
    var hasWebhookURL: Bool { self._webhookURL != nil }
    /// Clears the value of `webhookURL`. Subsequent reads from it will return its default value.
    mutating func clearWebhookURL() { _webhookURL = nil }

    /// sqs settings
    var sqsSettings: Stream_Video_SqsSettings {
        get { _sqsSettings ?? Stream_Video_SqsSettings() }
        set { _sqsSettings = newValue }
    }

    /// Returns true if `sqsSettings` has been explicitly set.
    var hasSqsSettings: Bool { self._sqsSettings != nil }
    /// Clears the value of `sqsSettings`. Subsequent reads from it will return its default value.
    mutating func clearSqsSettings() { _sqsSettings = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _webhookURL: SwiftProtobuf.Google_Protobuf_StringValue?
    private var _sqsSettings: Stream_Video_SqsSettings?
}

struct Stream_Video_AppSettingsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var settings: Stream_Video_ApplicationSettings {
        get { _settings ?? Stream_Video_ApplicationSettings() }
        set { _settings = newValue }
    }

    /// Returns true if `settings` has been explicitly set.
    var hasSettings: Bool { self._settings != nil }
    /// Clears the value of `settings`. Subsequent reads from it will return its default value.
    mutating func clearSettings() { _settings = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _settings: Stream_Video_ApplicationSettings?
}

struct Stream_Video_DeleteRoleRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the name of the role
    var name: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_DeleteRoleResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_CreateRoleRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the unique name for the role
    var name: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_CreateRoleResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_DeleteCallTypeRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the name of the call type
    var name: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_DeleteCallTypeResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_CallTypeResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the call type updated
    var callType: Stream_Video_CallType {
        get { _callType ?? Stream_Video_CallType() }
        set { _callType = newValue }
    }

    /// Returns true if `callType` has been explicitly set.
    var hasCallType: Bool { self._callType != nil }
    /// Clears the value of `callType`. Subsequent reads from it will return its default value.
    mutating func clearCallType() { _callType = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _callType: Stream_Video_CallType?
}

struct Stream_Video_CallTypeRequestInput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the name of the call type, must be unique for the application
    var name: String = String()

    /// the permission granted to users by their role
    var grants: [String: Stream_Video_Permissions] = [:]

    /// the feature settings
    var features: Stream_Video_Features {
        get { _features ?? Stream_Video_Features() }
        set { _features = newValue }
    }

    /// Returns true if `features` has been explicitly set.
    var hasFeatures: Bool { self._features != nil }
    /// Clears the value of `features`. Subsequent reads from it will return its default value.
    mutating func clearFeatures() { _features = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _features: Stream_Video_Features?
}

struct Stream_Video_ListPermissionsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callType: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_ListPermissionsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the set of permissions by user role
    var permissions: [String: Stream_Video_Permissions] = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_GetCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var type: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_GetCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Call {
        get { _call ?? Stream_Video_Call() }
        set { _call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { self._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _call = nil }

    var callState: Stream_Video_CallState {
        get { _callState ?? Stream_Video_CallState() }
        set { _callState = newValue }
    }

    /// Returns true if `callState` has been explicitly set.
    var hasCallState: Bool { self._callState != nil }
    /// Clears the value of `callState`. Subsequent reads from it will return its default value.
    mutating func clearCallState() { _callState = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _call: Stream_Video_Call?
    fileprivate var _callState: Stream_Video_CallState?
}

struct Stream_Video_CreateOrUpdateCallsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var calls: [Stream_Video_CreateCallRequest] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_CreateOrUpdateCallsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var calls: [Stream_Video_Call] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_CreateCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the call type
    var type: String = String()

    /// the call id, if not provided a unique value will be generated based on UUID v4
    var id: String = String()

    /// call custom data
    var custom: SwiftProtobuf.Google_Protobuf_Struct {
        get { _custom ?? SwiftProtobuf.Google_Protobuf_Struct() }
        set { _custom = newValue }
    }

    /// Returns true if `custom` has been explicitly set.
    var hasCustom: Bool { self._custom != nil }
    /// Clears the value of `custom`. Subsequent reads from it will return its default value.
    mutating func clearCustom() { _custom = nil }

    /// the list of participant ids
    var participantIds: [String] = []

    /// HLS broadcast, overrides the default call type setting if provided
    var hlsBroadcast: SwiftProtobuf.Google_Protobuf_BoolValue {
        get { _hlsBroadcast ?? SwiftProtobuf.Google_Protobuf_BoolValue() }
        set { _hlsBroadcast = newValue }
    }

    /// Returns true if `hlsBroadcast` has been explicitly set.
    var hasHlsBroadcast: Bool { self._hlsBroadcast != nil }
    /// Clears the value of `hlsBroadcast`. Subsequent reads from it will return its default value.
    mutating func clearHlsBroadcast() { _hlsBroadcast = nil }

    /// request video to be forwarded to a list of RTMP servers
    var rtmp: Stream_Video_RTMPOptions {
        get { _rtmp ?? Stream_Video_RTMPOptions() }
        set { _rtmp = newValue }
    }

    /// Returns true if `rtmp` has been explicitly set.
    var hasRtmp: Bool { self._rtmp != nil }
    /// Clears the value of `rtmp`. Subsequent reads from it will return its default value.
    mutating func clearRtmp() { _rtmp = nil }

    /// transcription, overrides the default call type setting if provided
    var transcribe: SwiftProtobuf.Google_Protobuf_BoolValue {
        get { _transcribe ?? SwiftProtobuf.Google_Protobuf_BoolValue() }
        set { _transcribe = newValue }
    }

    /// Returns true if `transcribe` has been explicitly set.
    var hasTranscribe: Bool { self._transcribe != nil }
    /// Clears the value of `transcribe`. Subsequent reads from it will return its default value.
    mutating func clearTranscribe() { _transcribe = nil }

    /// the transcription options for this call, only relevant if transcribe is enabled
    var transcribeOptions: Stream_Video_TranscribeOptions {
        get { _transcribeOptions ?? Stream_Video_TranscribeOptions() }
        set { _transcribeOptions = newValue }
    }

    /// Returns true if `transcribeOptions` has been explicitly set.
    var hasTranscribeOptions: Bool { self._transcribeOptions != nil }
    /// Clears the value of `transcribeOptions`. Subsequent reads from it will return its default value.
    mutating func clearTranscribeOptions() { _transcribeOptions = nil }

    /// the recording option, overrides the default call type setting if provided
    var recording: SwiftProtobuf.Google_Protobuf_BoolValue {
        get { _recording ?? SwiftProtobuf.Google_Protobuf_BoolValue() }
        set { _recording = newValue }
    }

    /// Returns true if `recording` has been explicitly set.
    var hasRecording: Bool { self._recording != nil }
    /// Clears the value of `recording`. Subsequent reads from it will return its default value.
    mutating func clearRecording() { _recording = nil }

    /// the ring option, overrides the default call type setting if provided
    var notify: SwiftProtobuf.Google_Protobuf_BoolValue {
        get { _notify ?? SwiftProtobuf.Google_Protobuf_BoolValue() }
        set { _notify = newValue }
    }

    /// Returns true if `notify` has been explicitly set.
    var hasNotify: Bool { self._notify != nil }
    /// Clears the value of `notify`. Subsequent reads from it will return its default value.
    mutating func clearNotify() { _notify = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct?
    private var _hlsBroadcast: SwiftProtobuf.Google_Protobuf_BoolValue?
    fileprivate var _rtmp: Stream_Video_RTMPOptions?
    private var _transcribe: SwiftProtobuf.Google_Protobuf_BoolValue?
    private var _transcribeOptions: Stream_Video_TranscribeOptions?
    private var _recording: SwiftProtobuf.Google_Protobuf_BoolValue?
    private var _notify: SwiftProtobuf.Google_Protobuf_BoolValue?
}

struct Stream_Video_CreateCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Call {
        get { _call ?? Stream_Video_Call() }
        set { _call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { self._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _call = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _call: Stream_Video_Call?
}

struct Stream_Video_UpdateCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var type: String = String()

    // TODO: additional options and overrides to default settings
    var jsonEncodedCustomData: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_UpdateCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Call {
        get { _call ?? Stream_Video_Call() }
        set { _call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { self._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _call = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _call: Stream_Video_Call?
}

struct Stream_Video_DeleteCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_DeleteCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_SelectEdgeServerRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callType: String = String()

    var callID: String = String()

    var latencyByEdge: [String: Stream_Video_Latency] = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_SelectEdgeServerResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the edge server hosting the video call
    var edgeServer: Stream_Video_EdgeServer {
        get { _edgeServer ?? Stream_Video_EdgeServer() }
        set { _edgeServer = newValue }
    }

    /// Returns true if `edgeServer` has been explicitly set.
    var hasEdgeServer: Bool { self._edgeServer != nil }
    /// Clears the value of `edgeServer`. Subsequent reads from it will return its default value.
    mutating func clearEdgeServer() { _edgeServer = nil }

    /// the auth token needed to authenticate to the edge server
    var token: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _edgeServer: Stream_Video_EdgeServer?
}

struct Stream_Video_AddDeviceRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the device id to register
    var id: String = String()

    /// the name of the push notification provider (eg. apn-production)
    var pushProviderName: String = String()

    /// the id of the user the device is registered to, only server-side requests can provide this
    var userID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_AddDeviceResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var device: Stream_Video_Device {
        get { _device ?? Stream_Video_Device() }
        set { _device = newValue }
    }

    /// Returns true if `device` has been explicitly set.
    var hasDevice: Bool { self._device != nil }
    /// Clears the value of `device`. Subsequent reads from it will return its default value.
    mutating func clearDevice() { _device = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _device: Stream_Video_Device?
}

struct Stream_Video_RemoveDeviceRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var userID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_RemoveDeviceResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_ListDevicesRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the id of the user, only server-side requests can provide this
    var userID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_ListDevicesResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var devices: [Stream_Video_Device] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_CreateUserRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var teams: [String] = []

    var role: String = String()

    var custom: SwiftProtobuf.Google_Protobuf_Struct {
        get { _custom ?? SwiftProtobuf.Google_Protobuf_Struct() }
        set { _custom = newValue }
    }

    /// Returns true if `custom` has been explicitly set.
    var hasCustom: Bool { self._custom != nil }
    /// Clears the value of `custom`. Subsequent reads from it will return its default value.
    mutating func clearCustom() { _custom = nil }

    var name: String = String()

    var imageURL: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct?
}

/// CreateOrUpdateUsersRequest runs a partial update or create on the list of users
/// specify replace = true to do a hard update instead of partial update
struct Stream_Video_CreateOrUpdateUsersRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var users: [Stream_Video_CreateUserRequest] = []

    /// full update (defaults to false and does a partial update)
    var fullUpdate: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_CreateOrUpdateUsersResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var users: [Stream_Video_User] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_DeleteUserRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

// TODO: do we support both soft and hard delete
struct Stream_Video_ExportUserRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

// TODO: talk about what data we should export on the GDPR endpoints for a user
struct Stream_Video_ExportUserResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_DeleteUserResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_CreateUserResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var user: Stream_Video_User {
        get { _user ?? Stream_Video_User() }
        set { _user = newValue }
    }

    /// Returns true if `user` has been explicitly set.
    var hasUser: Bool { self._user != nil }
    /// Clears the value of `user`. Subsequent reads from it will return its default value.
    mutating func clearUser() { _user = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _user: Stream_Video_User?
}

struct Stream_Video_SendCustomEventRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: String = String()

    var data: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_SendCustomEventResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_JoinCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var type: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_UserCapability {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var action: String = String()

    var description_p: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_JoinCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var user: Stream_Video_User {
        get { _storage._user ?? Stream_Video_User() }
        set { _uniqueStorage()._user = newValue }
    }

    /// Returns true if `user` has been explicitly set.
    var hasUser: Bool { _storage._user != nil }
    /// Clears the value of `user`. Subsequent reads from it will return its default value.
    mutating func clearUser() { _uniqueStorage()._user = nil }

    var call: Stream_Video_Call {
        get { _storage._call ?? Stream_Video_Call() }
        set { _uniqueStorage()._call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { _storage._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _uniqueStorage()._call = nil }

    var callState: Stream_Video_CallState {
        get { _storage._callState ?? Stream_Video_CallState() }
        set { _uniqueStorage()._callState = newValue }
    }

    /// Returns true if `callState` has been explicitly set.
    var hasCallState: Bool { _storage._callState != nil }
    /// Clears the value of `callState`. Subsequent reads from it will return its default value.
    mutating func clearCallState() { _uniqueStorage()._callState = nil }

    var edges: [Stream_Video_Edge] {
        get { _storage._edges }
        set { _uniqueStorage()._edges = newValue }
    }

    var ownCapabilities: [Stream_Video_UserCapability] {
        get { _storage._ownCapabilities }
        set { _uniqueStorage()._ownCapabilities = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _storage = _StorageClass.defaultInstance
}

struct Stream_Video_LeaveCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_LeaveCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_EndCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_EndCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_StartBroadcastRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// call id and type
    var callID: String = String()

    var callType: String = String()

    /// toggles HLS broadcasting on/off
    var hlsBroadcast: Bool = false

    /// enables rtmp broadcasting
    var rtmp: Stream_Video_RTMPOptions {
        get { _rtmp ?? Stream_Video_RTMPOptions() }
        set { _rtmp = newValue }
    }

    /// Returns true if `rtmp` has been explicitly set.
    var hasRtmp: Bool { self._rtmp != nil }
    /// Clears the value of `rtmp`. Subsequent reads from it will return its default value.
    mutating func clearRtmp() { _rtmp = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _rtmp: Stream_Video_RTMPOptions?
}

struct Stream_Video_StartBroadcastResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var broadcast: Stream_Video_Broadcast {
        get { _broadcast ?? Stream_Video_Broadcast() }
        set { _broadcast = newValue }
    }

    /// Returns true if `broadcast` has been explicitly set.
    var hasBroadcast: Bool { self._broadcast != nil }
    /// Clears the value of `broadcast`. Subsequent reads from it will return its default value.
    mutating func clearBroadcast() { _broadcast = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _broadcast: Stream_Video_Broadcast?
}

struct Stream_Video_StopBroadcastRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_StopBroadcastResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

// TODO: research what options we need here
struct Stream_Video_TranscribeCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_TranscribeCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_StopTranscribeCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_StopTranscribeCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_StoreLatencyRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_StoreLatencyResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_StartRecordingRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callType: String = String()

    var callID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_ReportCallStatsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The call type
    var callType: String = String()

    /// The call id
    var callID: String = String()

    /// A WebRTC Stats report, as defined in https://www.w3.org/TR/webrtc/#dom-rtcstatsreport
    var stats: SwiftProtobuf.Google_Protobuf_Struct {
        get { _stats ?? SwiftProtobuf.Google_Protobuf_Struct() }
        set { _stats = newValue }
    }

    /// Returns true if `stats` has been explicitly set.
    var hasStats: Bool { self._stats != nil }
    /// Clears the value of `stats`. Subsequent reads from it will return its default value.
    mutating func clearStats() { _stats = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _stats: SwiftProtobuf.Google_Protobuf_Struct?
}

struct Stream_Video_CallStatEvent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Stream_Video_CallStatEventType = .audioFrozenUnspecified

    /// call creation date as RFC3339 string
    var time: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_ReportIssueRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callType: String = String()

    var callID: String = String()

    /// optional description
    var description_p: String = String()

    var custom: SwiftProtobuf.Google_Protobuf_Struct {
        get { _custom ?? SwiftProtobuf.Google_Protobuf_Struct() }
        set { _custom = newValue }
    }

    /// Returns true if `custom` has been explicitly set.
    var hasCustom: Bool { self._custom != nil }
    /// Clears the value of `custom`. Subsequent reads from it will return its default value.
    mutating func clearCustom() { _custom = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct?
}

struct Stream_Video_ReviewCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callType: String = String()

    var callID: String = String()

    /// rating between 0 and 5 stars
    var stars: Float = 0

    /// optional description
    var description_p: String = String()

    /// optional custom data
    var custom: SwiftProtobuf.Google_Protobuf_Struct {
        get { _custom ?? SwiftProtobuf.Google_Protobuf_Struct() }
        set { _custom = newValue }
    }

    /// Returns true if `custom` has been explicitly set.
    var hasCustom: Bool { self._custom != nil }
    /// Clears the value of `custom`. Subsequent reads from it will return its default value.
    mutating func clearCustom() { _custom = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct?
}

struct Stream_Video_ReviewCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_ReportIssueResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_ParticipantCallStatEvent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var participantID: String = String()

    var callTimelines: [Stream_Video_CallStatEvent] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_GetCallStatsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callType: String = String()

    var callID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_CallStats {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callTimelines: [Stream_Video_CallStatEvent] = []

    var participantTimelines: [Stream_Video_ParticipantCallStatEvent] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_GetCallStatsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Call {
        get { _call ?? Stream_Video_Call() }
        set { _call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { self._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _call = nil }

    var callStats: Stream_Video_CallStats {
        get { _callStats ?? Stream_Video_CallStats() }
        set { _callStats = newValue }
    }

    /// Returns true if `callStats` has been explicitly set.
    var hasCallStats: Bool { self._callStats != nil }
    /// Clears the value of `callStats`. Subsequent reads from it will return its default value.
    mutating func clearCallStats() { _callStats = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _call: Stream_Video_Call?
    private var _callStats: Stream_Video_CallStats?
}

struct Stream_Video_ReportCallStatsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_StartRecordingResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_StopRecordingRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callType: String = String()

    var callID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_StopRecordingResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var s3FileURL: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

// TODO: how do we do filtering and pagination with proto?
/// here we need to be able to filter, sort and limit by
/// call id, call custom attribute, call creation time, call including a user, call by type
struct Stream_Video_GetRecordingsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_GetRecordingsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var recordings: [Stream_Video_GetRecordingsResponse.Recording] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Recording {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var callType: String = String()

        var callID: String = String()

        var s3FileURL: String = String()

        var startTime: String = String()

        var stopTime: String = String()

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
    }

    init() {}
}

struct Stream_Video_SendEventRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: String = String()

    var callType: String = String()

    var callID: String = String()

    var eventType: Stream_Video_UserEventType = .audioMutedUnspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_SendEventResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stream_Video_CallStatEventType: @unchecked Sendable {}
extension Stream_Video_UserEventType: @unchecked Sendable {}
extension Stream_Video_AddPushProviderRequest: @unchecked Sendable {}
extension Stream_Video_UpdatePushProviderRequest: @unchecked Sendable {}
extension Stream_Video_DeletePushProviderRequest: @unchecked Sendable {}
extension Stream_Video_UpdateAppSettingsRequest: @unchecked Sendable {}
extension Stream_Video_AppSettingsResponse: @unchecked Sendable {}
extension Stream_Video_DeleteRoleRequest: @unchecked Sendable {}
extension Stream_Video_DeleteRoleResponse: @unchecked Sendable {}
extension Stream_Video_CreateRoleRequest: @unchecked Sendable {}
extension Stream_Video_CreateRoleResponse: @unchecked Sendable {}
extension Stream_Video_DeleteCallTypeRequest: @unchecked Sendable {}
extension Stream_Video_DeleteCallTypeResponse: @unchecked Sendable {}
extension Stream_Video_CallTypeResponse: @unchecked Sendable {}
extension Stream_Video_CallTypeRequestInput: @unchecked Sendable {}
extension Stream_Video_ListPermissionsRequest: @unchecked Sendable {}
extension Stream_Video_ListPermissionsResponse: @unchecked Sendable {}
extension Stream_Video_GetCallRequest: @unchecked Sendable {}
extension Stream_Video_GetCallResponse: @unchecked Sendable {}
extension Stream_Video_CreateOrUpdateCallsRequest: @unchecked Sendable {}
extension Stream_Video_CreateOrUpdateCallsResponse: @unchecked Sendable {}
extension Stream_Video_CreateCallRequest: @unchecked Sendable {}
extension Stream_Video_CreateCallResponse: @unchecked Sendable {}
extension Stream_Video_UpdateCallRequest: @unchecked Sendable {}
extension Stream_Video_UpdateCallResponse: @unchecked Sendable {}
extension Stream_Video_DeleteCallRequest: @unchecked Sendable {}
extension Stream_Video_DeleteCallResponse: @unchecked Sendable {}
extension Stream_Video_SelectEdgeServerRequest: @unchecked Sendable {}
extension Stream_Video_SelectEdgeServerResponse: @unchecked Sendable {}
extension Stream_Video_AddDeviceRequest: @unchecked Sendable {}
extension Stream_Video_AddDeviceResponse: @unchecked Sendable {}
extension Stream_Video_RemoveDeviceRequest: @unchecked Sendable {}
extension Stream_Video_RemoveDeviceResponse: @unchecked Sendable {}
extension Stream_Video_ListDevicesRequest: @unchecked Sendable {}
extension Stream_Video_ListDevicesResponse: @unchecked Sendable {}
extension Stream_Video_CreateUserRequest: @unchecked Sendable {}
extension Stream_Video_CreateOrUpdateUsersRequest: @unchecked Sendable {}
extension Stream_Video_CreateOrUpdateUsersResponse: @unchecked Sendable {}
extension Stream_Video_DeleteUserRequest: @unchecked Sendable {}
extension Stream_Video_ExportUserRequest: @unchecked Sendable {}
extension Stream_Video_ExportUserResponse: @unchecked Sendable {}
extension Stream_Video_DeleteUserResponse: @unchecked Sendable {}
extension Stream_Video_CreateUserResponse: @unchecked Sendable {}
extension Stream_Video_SendCustomEventRequest: @unchecked Sendable {}
extension Stream_Video_SendCustomEventResponse: @unchecked Sendable {}
extension Stream_Video_JoinCallRequest: @unchecked Sendable {}
extension Stream_Video_UserCapability: @unchecked Sendable {}
extension Stream_Video_JoinCallResponse: @unchecked Sendable {}
extension Stream_Video_LeaveCallRequest: @unchecked Sendable {}
extension Stream_Video_LeaveCallResponse: @unchecked Sendable {}
extension Stream_Video_EndCallRequest: @unchecked Sendable {}
extension Stream_Video_EndCallResponse: @unchecked Sendable {}
extension Stream_Video_StartBroadcastRequest: @unchecked Sendable {}
extension Stream_Video_StartBroadcastResponse: @unchecked Sendable {}
extension Stream_Video_StopBroadcastRequest: @unchecked Sendable {}
extension Stream_Video_StopBroadcastResponse: @unchecked Sendable {}
extension Stream_Video_TranscribeCallRequest: @unchecked Sendable {}
extension Stream_Video_TranscribeCallResponse: @unchecked Sendable {}
extension Stream_Video_StopTranscribeCallRequest: @unchecked Sendable {}
extension Stream_Video_StopTranscribeCallResponse: @unchecked Sendable {}
extension Stream_Video_StoreLatencyRequest: @unchecked Sendable {}
extension Stream_Video_StoreLatencyResponse: @unchecked Sendable {}
extension Stream_Video_StartRecordingRequest: @unchecked Sendable {}
extension Stream_Video_ReportCallStatsRequest: @unchecked Sendable {}
extension Stream_Video_CallStatEvent: @unchecked Sendable {}
extension Stream_Video_ReportIssueRequest: @unchecked Sendable {}
extension Stream_Video_ReviewCallRequest: @unchecked Sendable {}
extension Stream_Video_ReviewCallResponse: @unchecked Sendable {}
extension Stream_Video_ReportIssueResponse: @unchecked Sendable {}
extension Stream_Video_ParticipantCallStatEvent: @unchecked Sendable {}
extension Stream_Video_GetCallStatsRequest: @unchecked Sendable {}
extension Stream_Video_CallStats: @unchecked Sendable {}
extension Stream_Video_GetCallStatsResponse: @unchecked Sendable {}
extension Stream_Video_ReportCallStatsResponse: @unchecked Sendable {}
extension Stream_Video_StartRecordingResponse: @unchecked Sendable {}
extension Stream_Video_StopRecordingRequest: @unchecked Sendable {}
extension Stream_Video_StopRecordingResponse: @unchecked Sendable {}
extension Stream_Video_GetRecordingsRequest: @unchecked Sendable {}
extension Stream_Video_GetRecordingsResponse: @unchecked Sendable {}
extension Stream_Video_GetRecordingsResponse.Recording: @unchecked Sendable {}
extension Stream_Video_SendEventRequest: @unchecked Sendable {}
extension Stream_Video_SendEventResponse: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "stream.video"

extension Stream_Video_CallStatEventType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "CALL_STAT_EVENT_TYPE_AUDIO_FROZEN_UNSPECIFIED"),
        1: .same(proto: "CALL_STAT_EVENT_TYPE_AUDIO_DELAY"),
        2: .same(proto: "CALL_STAT_EVENT_TYPE_VIDEO_FROZEN"),
        3: .same(proto: "CALL_STAT_EVENT_TYPE_VIDEO_DELAY"),
        4: .same(proto: "CALL_STAT_EVENT_TYPE_VIDEO_NOT_OPTIMAL")
    ]
}

extension Stream_Video_UserEventType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "USER_EVENT_TYPE_AUDIO_MUTED_UNSPECIFIED"),
        1: .same(proto: "USER_EVENT_TYPE_AUDIO_UNMUTED"),
        2: .same(proto: "USER_EVENT_TYPE_VIDEO_STARTED"),
        3: .same(proto: "USER_EVENT_TYPE_VIDEO_STOPPED")
    ]
}

extension Stream_Video_AddPushProviderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AddPushProviderRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "settings")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._settings {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_AddPushProviderRequest, rhs: Stream_Video_AddPushProviderRequest) -> Bool {
        if lhs._settings != rhs._settings { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_UpdatePushProviderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdatePushProviderRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "settings")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._settings {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_UpdatePushProviderRequest, rhs: Stream_Video_UpdatePushProviderRequest) -> Bool {
        if lhs._settings != rhs._settings { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_DeletePushProviderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeletePushProviderRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_DeletePushProviderRequest, rhs: Stream_Video_DeletePushProviderRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_UpdateAppSettingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateAppSettingsRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "webhook_url"),
        2: .standard(proto: "sqs_settings")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._webhookURL) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._sqsSettings) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._webhookURL {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._sqsSettings {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_UpdateAppSettingsRequest, rhs: Stream_Video_UpdateAppSettingsRequest) -> Bool {
        if lhs._webhookURL != rhs._webhookURL { return false }
        if lhs._sqsSettings != rhs._sqsSettings { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_AppSettingsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AppSettingsResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "settings")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._settings {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_AppSettingsResponse, rhs: Stream_Video_AppSettingsResponse) -> Bool {
        if lhs._settings != rhs._settings { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_DeleteRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeleteRoleRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_DeleteRoleRequest, rhs: Stream_Video_DeleteRoleRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_DeleteRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeleteRoleResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_DeleteRoleResponse, rhs: Stream_Video_DeleteRoleResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_CreateRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateRoleRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_CreateRoleRequest, rhs: Stream_Video_CreateRoleRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_CreateRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateRoleResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_CreateRoleResponse, rhs: Stream_Video_CreateRoleResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_DeleteCallTypeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeleteCallTypeRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_DeleteCallTypeRequest, rhs: Stream_Video_DeleteCallTypeRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_DeleteCallTypeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeleteCallTypeResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_DeleteCallTypeResponse, rhs: Stream_Video_DeleteCallTypeResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_CallTypeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CallTypeResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._callType) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._callType {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_CallTypeResponse, rhs: Stream_Video_CallTypeResponse) -> Bool {
        if lhs._callType != rhs._callType { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_CallTypeRequestInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CallTypeRequestInput"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "grants"),
        3: .same(proto: "features")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
            case 2: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString, Stream_Video_Permissions>.self,
                    value: &self.grants
                ) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._features) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if !grants.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString, Stream_Video_Permissions>.self,
                value: grants,
                fieldNumber: 2
            )
        }
        try { if let v = self._features {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_CallTypeRequestInput, rhs: Stream_Video_CallTypeRequestInput) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.grants != rhs.grants { return false }
        if lhs._features != rhs._features { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_ListPermissionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListPermissionsRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_ListPermissionsRequest, rhs: Stream_Video_ListPermissionsRequest) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_ListPermissionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListPermissionsResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "permissions")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString, Stream_Video_Permissions>.self,
                    value: &self.permissions
                ) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !permissions.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString, Stream_Video_Permissions>.self,
                value: permissions,
                fieldNumber: 1
            )
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_ListPermissionsResponse, rhs: Stream_Video_ListPermissionsResponse) -> Bool {
        if lhs.permissions != rhs.permissions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_GetCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "type")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_GetCallRequest, rhs: Stream_Video_GetCallRequest) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.type != rhs.type { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_GetCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetCallResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call"),
        2: .standard(proto: "call_state")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._callState) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._call {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._callState {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_GetCallResponse, rhs: Stream_Video_GetCallResponse) -> Bool {
        if lhs._call != rhs._call { return false }
        if lhs._callState != rhs._callState { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_CreateOrUpdateCallsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateOrUpdateCallsRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "calls")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.calls) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !calls.isEmpty {
            try visitor.visitRepeatedMessageField(value: calls, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_CreateOrUpdateCallsRequest, rhs: Stream_Video_CreateOrUpdateCallsRequest) -> Bool {
        if lhs.calls != rhs.calls { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_CreateOrUpdateCallsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateOrUpdateCallsResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "calls")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.calls) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !calls.isEmpty {
            try visitor.visitRepeatedMessageField(value: calls, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_CreateOrUpdateCallsResponse, rhs: Stream_Video_CreateOrUpdateCallsResponse) -> Bool {
        if lhs.calls != rhs.calls { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_CreateCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "id"),
        3: .same(proto: "custom"),
        4: .standard(proto: "participant_ids"),
        6: .standard(proto: "hls_broadcast"),
        7: .same(proto: "rtmp"),
        8: .same(proto: "transcribe"),
        9: .standard(proto: "transcribe_options"),
        10: .same(proto: "recording"),
        11: .same(proto: "notify")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
            case 4: try { try decoder.decodeRepeatedStringField(value: &self.participantIds) }()
            case 6: try { try decoder.decodeSingularMessageField(value: &self._hlsBroadcast) }()
            case 7: try { try decoder.decodeSingularMessageField(value: &self._rtmp) }()
            case 8: try { try decoder.decodeSingularMessageField(value: &self._transcribe) }()
            case 9: try { try decoder.decodeSingularMessageField(value: &self._transcribeOptions) }()
            case 10: try { try decoder.decodeSingularMessageField(value: &self._recording) }()
            case 11: try { try decoder.decodeSingularMessageField(value: &self._notify) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 1)
        }
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 2)
        }
        try { if let v = self._custom {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        if !participantIds.isEmpty {
            try visitor.visitRepeatedStringField(value: participantIds, fieldNumber: 4)
        }
        try { if let v = self._hlsBroadcast {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
        } }()
        try { if let v = self._rtmp {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
        } }()
        try { if let v = self._transcribe {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
        } }()
        try { if let v = self._transcribeOptions {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
        } }()
        try { if let v = self._recording {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
        } }()
        try { if let v = self._notify {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_CreateCallRequest, rhs: Stream_Video_CreateCallRequest) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.id != rhs.id { return false }
        if lhs._custom != rhs._custom { return false }
        if lhs.participantIds != rhs.participantIds { return false }
        if lhs._hlsBroadcast != rhs._hlsBroadcast { return false }
        if lhs._rtmp != rhs._rtmp { return false }
        if lhs._transcribe != rhs._transcribe { return false }
        if lhs._transcribeOptions != rhs._transcribeOptions { return false }
        if lhs._recording != rhs._recording { return false }
        if lhs._notify != rhs._notify { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_CreateCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateCallResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._call {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_CreateCallResponse, rhs: Stream_Video_CreateCallResponse) -> Bool {
        if lhs._call != rhs._call { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_UpdateCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "type"),
        3: .standard(proto: "json_encoded_custom_data")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
            case 3: try { try decoder.decodeSingularBytesField(value: &self.jsonEncodedCustomData) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 2)
        }
        if !jsonEncodedCustomData.isEmpty {
            try visitor.visitSingularBytesField(value: jsonEncodedCustomData, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_UpdateCallRequest, rhs: Stream_Video_UpdateCallRequest) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.type != rhs.type { return false }
        if lhs.jsonEncodedCustomData != rhs.jsonEncodedCustomData { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_UpdateCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateCallResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._call {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_UpdateCallResponse, rhs: Stream_Video_UpdateCallResponse) -> Bool {
        if lhs._call != rhs._call { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_DeleteCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeleteCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_DeleteCallRequest, rhs: Stream_Video_DeleteCallRequest) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_DeleteCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeleteCallResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_DeleteCallResponse, rhs: Stream_Video_DeleteCallResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_SelectEdgeServerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SelectEdgeServerRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type"),
        2: .standard(proto: "call_id"),
        3: .standard(proto: "latency_by_edge")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            case 3: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString, Stream_Video_Latency>.self,
                    value: &self.latencyByEdge
                ) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 2)
        }
        if !latencyByEdge.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString, Stream_Video_Latency>.self,
                value: latencyByEdge,
                fieldNumber: 3
            )
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_SelectEdgeServerRequest, rhs: Stream_Video_SelectEdgeServerRequest) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs.latencyByEdge != rhs.latencyByEdge { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_SelectEdgeServerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SelectEdgeServerResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "edge_server"),
        2: .same(proto: "token")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._edgeServer) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._edgeServer {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !token.isEmpty {
            try visitor.visitSingularStringField(value: token, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_SelectEdgeServerResponse, rhs: Stream_Video_SelectEdgeServerResponse) -> Bool {
        if lhs._edgeServer != rhs._edgeServer { return false }
        if lhs.token != rhs.token { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_AddDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AddDeviceRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "push_provider_name"),
        3: .standard(proto: "user_id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.pushProviderName) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !pushProviderName.isEmpty {
            try visitor.visitSingularStringField(value: pushProviderName, fieldNumber: 2)
        }
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_AddDeviceRequest, rhs: Stream_Video_AddDeviceRequest) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.pushProviderName != rhs.pushProviderName { return false }
        if lhs.userID != rhs.userID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_AddDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AddDeviceResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "device")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._device {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_AddDeviceResponse, rhs: Stream_Video_AddDeviceResponse) -> Bool {
        if lhs._device != rhs._device { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_RemoveDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RemoveDeviceRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "user_id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_RemoveDeviceRequest, rhs: Stream_Video_RemoveDeviceRequest) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.userID != rhs.userID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_RemoveDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RemoveDeviceResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_RemoveDeviceResponse, rhs: Stream_Video_RemoveDeviceResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_ListDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListDevicesRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_ListDevicesRequest, rhs: Stream_Video_ListDevicesRequest) -> Bool {
        if lhs.userID != rhs.userID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_ListDevicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ListDevicesResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "devices")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !devices.isEmpty {
            try visitor.visitRepeatedMessageField(value: devices, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_ListDevicesResponse, rhs: Stream_Video_ListDevicesResponse) -> Bool {
        if lhs.devices != rhs.devices { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_CreateUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateUserRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "teams"),
        3: .same(proto: "role"),
        4: .same(proto: "custom"),
        5: .same(proto: "name"),
        6: .standard(proto: "image_url")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 2: try { try decoder.decodeRepeatedStringField(value: &self.teams) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.role) }()
            case 4: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
            case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
            case 6: try { try decoder.decodeSingularStringField(value: &self.imageURL) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !teams.isEmpty {
            try visitor.visitRepeatedStringField(value: teams, fieldNumber: 2)
        }
        if !role.isEmpty {
            try visitor.visitSingularStringField(value: role, fieldNumber: 3)
        }
        try { if let v = self._custom {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 5)
        }
        if !imageURL.isEmpty {
            try visitor.visitSingularStringField(value: imageURL, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_CreateUserRequest, rhs: Stream_Video_CreateUserRequest) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.teams != rhs.teams { return false }
        if lhs.role != rhs.role { return false }
        if lhs._custom != rhs._custom { return false }
        if lhs.name != rhs.name { return false }
        if lhs.imageURL != rhs.imageURL { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_CreateOrUpdateUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateOrUpdateUsersRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "users"),
        2: .standard(proto: "full_update")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.fullUpdate) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !users.isEmpty {
            try visitor.visitRepeatedMessageField(value: users, fieldNumber: 1)
        }
        if fullUpdate != false {
            try visitor.visitSingularBoolField(value: fullUpdate, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_CreateOrUpdateUsersRequest, rhs: Stream_Video_CreateOrUpdateUsersRequest) -> Bool {
        if lhs.users != rhs.users { return false }
        if lhs.fullUpdate != rhs.fullUpdate { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_CreateOrUpdateUsersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateOrUpdateUsersResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "users")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !users.isEmpty {
            try visitor.visitRepeatedMessageField(value: users, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_CreateOrUpdateUsersResponse, rhs: Stream_Video_CreateOrUpdateUsersResponse) -> Bool {
        if lhs.users != rhs.users { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_DeleteUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeleteUserRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_DeleteUserRequest, rhs: Stream_Video_DeleteUserRequest) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_ExportUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ExportUserRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_ExportUserRequest, rhs: Stream_Video_ExportUserRequest) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_ExportUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ExportUserResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_ExportUserResponse, rhs: Stream_Video_ExportUserResponse) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_DeleteUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeleteUserResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_DeleteUserResponse, rhs: Stream_Video_DeleteUserResponse) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_CreateUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateUserResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "user")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._user) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._user {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_CreateUserResponse, rhs: Stream_Video_CreateUserResponse) -> Bool {
        if lhs._user != rhs._user { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_SendCustomEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SendCustomEventRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "data")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
            case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 1)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_SendCustomEventRequest, rhs: Stream_Video_SendCustomEventRequest) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_SendCustomEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SendCustomEventResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_SendCustomEventResponse, rhs: Stream_Video_SendCustomEventResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_JoinCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".JoinCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "type")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_JoinCallRequest, rhs: Stream_Video_JoinCallRequest) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.type != rhs.type { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_UserCapability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UserCapability"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "action"),
        2: .same(proto: "description")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.action) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !action.isEmpty {
            try visitor.visitSingularStringField(value: action, fieldNumber: 1)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_UserCapability, rhs: Stream_Video_UserCapability) -> Bool {
        if lhs.action != rhs.action { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_JoinCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".JoinCallResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "user"),
        2: .same(proto: "call"),
        3: .standard(proto: "call_state"),
        4: .same(proto: "edges"),
        5: .standard(proto: "own_capabilities")
    ]

    fileprivate class _StorageClass {
        var _user: Stream_Video_User?
        var _call: Stream_Video_Call?
        var _callState: Stream_Video_CallState?
        var _edges: [Stream_Video_Edge] = []
        var _ownCapabilities: [Stream_Video_UserCapability] = []

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _user = source._user
            _call = source._call
            _callState = source._callState
            _edges = source._edges
            _ownCapabilities = source._ownCapabilities
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
                case 2: try { try decoder.decodeSingularMessageField(value: &_storage._call) }()
                case 3: try { try decoder.decodeSingularMessageField(value: &_storage._callState) }()
                case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._edges) }()
                case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._ownCapabilities) }()
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._user {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            try { if let v = _storage._call {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            try { if let v = _storage._callState {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            } }()
            if !_storage._edges.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._edges, fieldNumber: 4)
            }
            if !_storage._ownCapabilities.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._ownCapabilities, fieldNumber: 5)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_JoinCallResponse, rhs: Stream_Video_JoinCallResponse) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool =
                withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                    let _storage = _args.0
                    let rhs_storage = _args.1
                    if _storage._user != rhs_storage._user { return false }
                    if _storage._call != rhs_storage._call { return false }
                    if _storage._callState != rhs_storage._callState { return false }
                    if _storage._edges != rhs_storage._edges { return false }
                    if _storage._ownCapabilities != rhs_storage._ownCapabilities { return false }
                    return true
                }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_LeaveCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".LeaveCallRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_LeaveCallRequest, rhs: Stream_Video_LeaveCallRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_LeaveCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".LeaveCallResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_LeaveCallResponse, rhs: Stream_Video_LeaveCallResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_EndCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".EndCallRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_EndCallRequest, rhs: Stream_Video_EndCallRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_EndCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".EndCallResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_EndCallResponse, rhs: Stream_Video_EndCallResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_StartBroadcastRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StartBroadcastRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_id"),
        2: .standard(proto: "call_type"),
        3: .standard(proto: "hls_broadcast"),
        5: .same(proto: "rtmp")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.hlsBroadcast) }()
            case 5: try { try decoder.decodeSingularMessageField(value: &self._rtmp) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 1)
        }
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 2)
        }
        if hlsBroadcast != false {
            try visitor.visitSingularBoolField(value: hlsBroadcast, fieldNumber: 3)
        }
        try { if let v = self._rtmp {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_StartBroadcastRequest, rhs: Stream_Video_StartBroadcastRequest) -> Bool {
        if lhs.callID != rhs.callID { return false }
        if lhs.callType != rhs.callType { return false }
        if lhs.hlsBroadcast != rhs.hlsBroadcast { return false }
        if lhs._rtmp != rhs._rtmp { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_StartBroadcastResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StartBroadcastResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "broadcast")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._broadcast) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._broadcast {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_StartBroadcastResponse, rhs: Stream_Video_StartBroadcastResponse) -> Bool {
        if lhs._broadcast != rhs._broadcast { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_StopBroadcastRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StopBroadcastRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_StopBroadcastRequest, rhs: Stream_Video_StopBroadcastRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_StopBroadcastResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StopBroadcastResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_StopBroadcastResponse, rhs: Stream_Video_StopBroadcastResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_TranscribeCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".TranscribeCallRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_TranscribeCallRequest, rhs: Stream_Video_TranscribeCallRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_TranscribeCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".TranscribeCallResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_TranscribeCallResponse, rhs: Stream_Video_TranscribeCallResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_StopTranscribeCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StopTranscribeCallRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_StopTranscribeCallRequest, rhs: Stream_Video_StopTranscribeCallRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_StopTranscribeCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StopTranscribeCallResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_StopTranscribeCallResponse, rhs: Stream_Video_StopTranscribeCallResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_StoreLatencyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StoreLatencyRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_StoreLatencyRequest, rhs: Stream_Video_StoreLatencyRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_StoreLatencyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StoreLatencyResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_StoreLatencyResponse, rhs: Stream_Video_StoreLatencyResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_StartRecordingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StartRecordingRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type"),
        2: .standard(proto: "call_id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_StartRecordingRequest, rhs: Stream_Video_StartRecordingRequest) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_ReportCallStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReportCallStatsRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type"),
        2: .standard(proto: "call_id"),
        3: .same(proto: "stats")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 2)
        }
        try { if let v = self._stats {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_ReportCallStatsRequest, rhs: Stream_Video_ReportCallStatsRequest) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs._stats != rhs._stats { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_CallStatEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CallStatEvent"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "time")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.time) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if type != .audioFrozenUnspecified {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 1)
        }
        if !time.isEmpty {
            try visitor.visitSingularStringField(value: time, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_CallStatEvent, rhs: Stream_Video_CallStatEvent) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.time != rhs.time { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_ReportIssueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReportIssueRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type"),
        2: .standard(proto: "call_id"),
        3: .same(proto: "description"),
        4: .same(proto: "custom")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
            case 4: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 2)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 3)
        }
        try { if let v = self._custom {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_ReportIssueRequest, rhs: Stream_Video_ReportIssueRequest) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs._custom != rhs._custom { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_ReviewCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReviewCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type"),
        2: .standard(proto: "call_id"),
        3: .same(proto: "stars"),
        4: .same(proto: "description"),
        5: .same(proto: "custom")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            case 3: try { try decoder.decodeSingularFloatField(value: &self.stars) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
            case 5: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 2)
        }
        if stars != 0 {
            try visitor.visitSingularFloatField(value: stars, fieldNumber: 3)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 4)
        }
        try { if let v = self._custom {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_ReviewCallRequest, rhs: Stream_Video_ReviewCallRequest) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs.stars != rhs.stars { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs._custom != rhs._custom { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_ReviewCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReviewCallResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_ReviewCallResponse, rhs: Stream_Video_ReviewCallResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_ReportIssueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReportIssueResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_ReportIssueResponse, rhs: Stream_Video_ReportIssueResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_ParticipantCallStatEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ParticipantCallStatEvent"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "participant_id"),
        2: .standard(proto: "call_timelines")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.participantID) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.callTimelines) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !participantID.isEmpty {
            try visitor.visitSingularStringField(value: participantID, fieldNumber: 1)
        }
        if !callTimelines.isEmpty {
            try visitor.visitRepeatedMessageField(value: callTimelines, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_ParticipantCallStatEvent, rhs: Stream_Video_ParticipantCallStatEvent) -> Bool {
        if lhs.participantID != rhs.participantID { return false }
        if lhs.callTimelines != rhs.callTimelines { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_GetCallStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetCallStatsRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type"),
        2: .standard(proto: "call_id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_GetCallStatsRequest, rhs: Stream_Video_GetCallStatsRequest) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_CallStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CallStats"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_timelines"),
        2: .standard(proto: "participant_timelines")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.callTimelines) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.participantTimelines) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callTimelines.isEmpty {
            try visitor.visitRepeatedMessageField(value: callTimelines, fieldNumber: 1)
        }
        if !participantTimelines.isEmpty {
            try visitor.visitRepeatedMessageField(value: participantTimelines, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_CallStats, rhs: Stream_Video_CallStats) -> Bool {
        if lhs.callTimelines != rhs.callTimelines { return false }
        if lhs.participantTimelines != rhs.participantTimelines { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_GetCallStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetCallStatsResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call"),
        2: .standard(proto: "call_stats")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._callStats) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._call {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._callStats {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_GetCallStatsResponse, rhs: Stream_Video_GetCallStatsResponse) -> Bool {
        if lhs._call != rhs._call { return false }
        if lhs._callStats != rhs._callStats { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_ReportCallStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReportCallStatsResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_ReportCallStatsResponse, rhs: Stream_Video_ReportCallStatsResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_StartRecordingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StartRecordingResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_StartRecordingResponse, rhs: Stream_Video_StartRecordingResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_StopRecordingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StopRecordingRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type"),
        2: .standard(proto: "call_id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_StopRecordingRequest, rhs: Stream_Video_StopRecordingRequest) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_StopRecordingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StopRecordingResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "s3_file_url")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.s3FileURL) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !s3FileURL.isEmpty {
            try visitor.visitSingularStringField(value: s3FileURL, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_StopRecordingResponse, rhs: Stream_Video_StopRecordingResponse) -> Bool {
        if lhs.s3FileURL != rhs.s3FileURL { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_GetRecordingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetRecordingsRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_GetRecordingsRequest, rhs: Stream_Video_GetRecordingsRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_GetRecordingsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetRecordingsResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "recordings")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.recordings) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !recordings.isEmpty {
            try visitor.visitRepeatedMessageField(value: recordings, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_GetRecordingsResponse, rhs: Stream_Video_GetRecordingsResponse) -> Bool {
        if lhs.recordings != rhs.recordings { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_GetRecordingsResponse.Recording: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Stream_Video_GetRecordingsResponse.protoMessageName + ".Recording"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type"),
        2: .standard(proto: "call_id"),
        3: .standard(proto: "s3_file_url"),
        4: .standard(proto: "start_time"),
        5: .standard(proto: "stop_time")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.s3FileURL) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self.startTime) }()
            case 5: try { try decoder.decodeSingularStringField(value: &self.stopTime) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 2)
        }
        if !s3FileURL.isEmpty {
            try visitor.visitSingularStringField(value: s3FileURL, fieldNumber: 3)
        }
        if !startTime.isEmpty {
            try visitor.visitSingularStringField(value: startTime, fieldNumber: 4)
        }
        if !stopTime.isEmpty {
            try visitor.visitSingularStringField(value: stopTime, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_GetRecordingsResponse.Recording, rhs: Stream_Video_GetRecordingsResponse.Recording) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs.s3FileURL != rhs.s3FileURL { return false }
        if lhs.startTime != rhs.startTime { return false }
        if lhs.stopTime != rhs.stopTime { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_SendEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SendEventRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_id"),
        2: .standard(proto: "call_type"),
        3: .standard(proto: "call_id"),
        4: .standard(proto: "event_type")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            case 4: try { try decoder.decodeSingularEnumField(value: &self.eventType) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 1)
        }
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 2)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 3)
        }
        if eventType != .audioMutedUnspecified {
            try visitor.visitSingularEnumField(value: eventType, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_SendEventRequest, rhs: Stream_Video_SendEventRequest) -> Bool {
        if lhs.userID != rhs.userID { return false }
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs.eventType != rhs.eventType { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_SendEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SendEventResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_SendEventResponse, rhs: Stream_Video_SendEventResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
