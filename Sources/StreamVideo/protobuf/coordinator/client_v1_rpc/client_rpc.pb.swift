//
// Copyright Â© 2022 Stream.io Inc. All rights reserved.
//

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

enum Stream_Video_Coordinator_ClientV1Rpc_MemberField: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0
    case role // = 1
    case custom // = 2
    case UNRECOGNIZED(Int)

    init() {
        self = .unspecified
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .role
        case 2: self = .custom
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .role: return 1
        case .custom: return 2
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

extension Stream_Video_Coordinator_ClientV1Rpc_MemberField: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Stream_Video_Coordinator_ClientV1Rpc_MemberField] = [
        .unspecified,
        .role,
        .custom
    ]
}

#endif // swift(>=4.2)

enum Stream_Video_Coordinator_ClientV1Rpc_UserEventType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0
    case acceptedCall // = 1
    case rejectedCall // = 2
    case cancelledCall // = 3
    case UNRECOGNIZED(Int)

    init() {
        self = .unspecified
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .acceptedCall
        case 2: self = .rejectedCall
        case 3: self = .cancelledCall
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .acceptedCall: return 1
        case .rejectedCall: return 2
        case .cancelledCall: return 3
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

extension Stream_Video_Coordinator_ClientV1Rpc_UserEventType: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Stream_Video_Coordinator_ClientV1Rpc_UserEventType] = [
        .unspecified,
        .acceptedCall,
        .rejectedCall,
        .cancelledCall
    ]
}

#endif // swift(>=4.2)

struct Stream_Video_Coordinator_ClientV1Rpc_GetCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callCid: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_GetCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope {
        get { _call ?? Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope() }
        set { _call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { self._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _call = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope?
}

struct Stream_Video_Coordinator_ClientV1Rpc_MemberInput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var role: String = String()

    var customJson: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_UpdateCallMembersRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callCid: String = String()

    var members: [String: Stream_Video_Coordinator_ClientV1Rpc_MemberInput] = [:]

    var fields: [Stream_Video_Coordinator_ClientV1Rpc_MemberField] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_UpdateCallMembersResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callCid: String = String()

    var userIds: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// A message that carries data for call creation
struct Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Call properties to set
    var call: Stream_Video_Coordinator_ClientV1Rpc_CallInput {
        get { _call ?? Stream_Video_Coordinator_ClientV1Rpc_CallInput() }
        set { _call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { self._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _call = nil }

    /// Members to add to the created call
    var members: [String: Stream_Video_Coordinator_ClientV1Rpc_MemberInput] = [:]

    /// Ringing option, used to signal to clients' UI
    var ring: Bool {
        get { _ring ?? false }
        set { _ring = newValue }
    }

    /// Returns true if `ring` has been explicitly set.
    var hasRing: Bool { self._ring != nil }
    /// Clears the value of `ring`. Subsequent reads from it will return its default value.
    mutating func clearRing() { _ring = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _call: Stream_Video_Coordinator_ClientV1Rpc_CallInput?
    fileprivate var _ring: Bool?
}

/// A request message for GetOrCreateCall endpoint
struct Stream_Video_Coordinator_ClientV1Rpc_CreateCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Call type
    var type: String = String()

    /// Call ID. If empty, will be generated as UUIDv4
    var id: String {
        get { _id ?? String() }
        set { _id = newValue }
    }

    /// Returns true if `id` has been explicitly set.
    var hasID: Bool { self._id != nil }
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() { _id = nil }

    /// Call creation input, only used if the call does not exist
    var input: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput {
        get { _input ?? Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput() }
        set { _input = newValue }
    }

    /// Returns true if `input` has been explicitly set.
    var hasInput: Bool { self._input != nil }
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    mutating func clearInput() { _input = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _id: String?
    fileprivate var _input: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput?
}

/// A request message for GetOrCreateCall endpoint
struct Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Call type
    var type: String = String()

    /// Call ID
    var id: String = String()

    /// Call creation input, only used if the call does not exist
    var input: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput {
        get { _input ?? Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput() }
        set { _input = newValue }
    }

    /// Returns true if `input` has been explicitly set.
    var hasInput: Bool { self._input != nil }
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    mutating func clearInput() { _input = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _input: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput?
}

/// A request message for JoinCall endpoint
struct Stream_Video_Coordinator_ClientV1Rpc_JoinCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Call type
    var type: String = String()

    /// Call ID
    var id: String = String()

    /// Call creation input, only used if the call does not exist
    var input: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput {
        get { _input ?? Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput() }
        set { _input = newValue }
    }

    /// Returns true if `input` has been explicitly set.
    var hasInput: Bool { self._input != nil }
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    mutating func clearInput() { _input = nil }

    /// Preferred client datacenter. This is optional and when set, preferred datacenter selection is not guaranteed
    var datacenterID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _input: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput?
}

/// A request message for GetOrCreateCall endpoint
struct Stream_Video_Coordinator_ClientV1Rpc_JoinCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope {
        get { _storage._call ?? Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope() }
        set { _uniqueStorage()._call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { _storage._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _uniqueStorage()._call = nil }

    /// Whether a call was created
    var created: Bool {
        get { _storage._created }
        set { _uniqueStorage()._created = newValue }
    }

    /// A list of endpoints to measure latency
    var edges: [Stream_Video_Coordinator_EdgeV1_Edge] {
        get { _storage._edges }
        set { _uniqueStorage()._edges = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents all updatable room fields
struct Stream_Video_Coordinator_ClientV1Rpc_CallInput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Custom JSON object that is stored in this call
    /// All users with read permissions will have access to this object
    var customJson: Data = Data()

    /// Call options to set
    var options: Stream_Video_Coordinator_CallV1_CallOptions {
        get { _options ?? Stream_Video_Coordinator_CallV1_CallOptions() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    var hasOptions: Bool { self._options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    mutating func clearOptions() { _options = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _options: Stream_Video_Coordinator_CallV1_CallOptions?
}

struct Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope {
        get { _storage._call ?? Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope() }
        set { _uniqueStorage()._call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { _storage._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _uniqueStorage()._call = nil }

    /// Whether a call was created
    var created: Bool {
        get { _storage._created }
        set { _uniqueStorage()._created = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

struct Stream_Video_Coordinator_ClientV1Rpc_UpdateCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callCid: String = String()

    var input: Stream_Video_Coordinator_ClientV1Rpc_CallInput {
        get { _input ?? Stream_Video_Coordinator_ClientV1Rpc_CallInput() }
        set { _input = newValue }
    }

    /// Returns true if `input` has been explicitly set.
    var hasInput: Bool { self._input != nil }
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    mutating func clearInput() { _input = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _input: Stream_Video_Coordinator_ClientV1Rpc_CallInput?
}

struct Stream_Video_Coordinator_ClientV1Rpc_UpdateCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope {
        get { _call ?? Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope() }
        set { _call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { self._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _call = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope?
}

struct Stream_Video_Coordinator_ClientV1Rpc_CreateCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope {
        get { _call ?? Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope() }
        set { _call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { self._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _call = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope?
}

struct Stream_Video_Coordinator_ClientV1Rpc_QueryCallsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mqJson: Data = Data()

    var limit: Int32 {
        get { _limit ?? 0 }
        set { _limit = newValue }
    }

    /// Returns true if `limit` has been explicitly set.
    var hasLimit: Bool { self._limit != nil }
    /// Clears the value of `limit`. Subsequent reads from it will return its default value.
    mutating func clearLimit() { _limit = nil }

    var sorts: [Stream_Video_Coordinator_UtilsV1_Sort] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _limit: Int32?
}

struct Stream_Video_Coordinator_ClientV1Rpc_QueryCallsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var calls: Stream_Video_Coordinator_ClientV1Rpc_CallsEnvelope {
        get { _calls ?? Stream_Video_Coordinator_ClientV1Rpc_CallsEnvelope() }
        set { _calls = newValue }
    }

    /// Returns true if `calls` has been explicitly set.
    var hasCalls: Bool { self._calls != nil }
    /// Clears the value of `calls`. Subsequent reads from it will return its default value.
    mutating func clearCalls() { _calls = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _calls: Stream_Video_Coordinator_ClientV1Rpc_CallsEnvelope?
}

struct Stream_Video_Coordinator_ClientV1Rpc_QueryMembersRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mqJson: Data = Data()

    var limit: Int32 {
        get { _limit ?? 0 }
        set { _limit = newValue }
    }

    /// Returns true if `limit` has been explicitly set.
    var hasLimit: Bool { self._limit != nil }
    /// Clears the value of `limit`. Subsequent reads from it will return its default value.
    mutating func clearLimit() { _limit = nil }

    var sorts: [Stream_Video_Coordinator_UtilsV1_Sort] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _limit: Int32?
}

struct Stream_Video_Coordinator_ClientV1Rpc_QueryMembersResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var members: Stream_Video_Coordinator_ClientV1Rpc_MembersEnvelope {
        get { _members ?? Stream_Video_Coordinator_ClientV1Rpc_MembersEnvelope() }
        set { _members = newValue }
    }

    /// Returns true if `members` has been explicitly set.
    var hasMembers: Bool { self._members != nil }
    /// Clears the value of `members`. Subsequent reads from it will return its default value.
    mutating func clearMembers() { _members = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _members: Stream_Video_Coordinator_ClientV1Rpc_MembersEnvelope?
}

/// A request message for GetCallEdgeServer endpoint
struct Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Call CID to get SFU for
    var callCid: String = String()

    /// Latency measurement results
    /// Optional
    var measurements: Stream_Video_Coordinator_EdgeV1_LatencyMeasurements {
        get { _measurements ?? Stream_Video_Coordinator_EdgeV1_LatencyMeasurements() }
        set { _measurements = newValue }
    }

    /// Returns true if `measurements` has been explicitly set.
    var hasMeasurements: Bool { self._measurements != nil }
    /// Clears the value of `measurements`. Subsequent reads from it will return its default value.
    mutating func clearMeasurements() { _measurements = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _measurements: Stream_Video_Coordinator_EdgeV1_LatencyMeasurements?
}

struct Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope {
        get { _storage._call ?? Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope() }
        set { _uniqueStorage()._call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { _storage._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _uniqueStorage()._call = nil }

    /// Call edge server credentials
    var credentials: Stream_Video_Coordinator_EdgeV1_Credentials {
        get { _storage._credentials ?? Stream_Video_Coordinator_EdgeV1_Credentials() }
        set { _uniqueStorage()._credentials = newValue }
    }

    /// Returns true if `credentials` has been explicitly set.
    var hasCredentials: Bool { _storage._credentials != nil }
    /// Clears the value of `credentials`. Subsequent reads from it will return its default value.
    mutating func clearCredentials() { _uniqueStorage()._credentials = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

struct Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var input: Stream_Video_Coordinator_PushV1_DeviceInput {
        get { _input ?? Stream_Video_Coordinator_PushV1_DeviceInput() }
        set { _input = newValue }
    }

    /// Returns true if `input` has been explicitly set.
    var hasInput: Bool { self._input != nil }
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    mutating func clearInput() { _input = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _input: Stream_Video_Coordinator_PushV1_DeviceInput?
}

struct Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var device: Stream_Video_Coordinator_PushV1_Device {
        get { _device ?? Stream_Video_Coordinator_PushV1_Device() }
        set { _device = newValue }
    }

    /// Returns true if `device` has been explicitly set.
    var hasDevice: Bool { self._device != nil }
    /// Clears the value of `device`. Subsequent reads from it will return its default value.
    mutating func clearDevice() { _device = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _device: Stream_Video_Coordinator_PushV1_Device?
}

struct Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var devices: [Stream_Video_Coordinator_PushV1_Device] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_SendEventRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The call cid
    var callCid: String = String()

    /// The type of event
    var eventType: Stream_Video_Coordinator_ClientV1Rpc_UserEventType = .unspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_SendEventResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The call cid
    var callCid: String = String()

    /// The type of event
    var type: String = String()

    /// The data of the event
    var dataJson: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The call type
    var callType: String = String()

    /// The call id
    var callID: String = String()

    /// A WebRTC Stats report encoded as a JSON string, as defined in https://www.w3.org/TR/webrtc/#dom-rtcstatsreport
    var statsJson: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_GetCallStatsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callType: String = String()

    var callID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_ReportIssueRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callType: String = String()

    var callID: String = String()

    /// Optional description.
    var description_p: String = String()

    var customJson: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_ReportIssueResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_ReviewCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callType: String = String()

    var callID: String = String()

    /// Rating between 0 and 5 stars.
    var stars: Float = 0

    /// Optional description.
    var description_p: String = String()

    /// Optional custom data.
    var customJson: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_ReviewCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stream_Video_Coordinator_ClientV1Rpc_MemberField: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_UserEventType: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_GetCallRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_GetCallResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_MemberInput: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_UpdateCallMembersRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_UpdateCallMembersResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_CreateCallRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_JoinCallRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_JoinCallResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_CallInput: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_UpdateCallRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_UpdateCallResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_CreateCallResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_QueryCallsRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_QueryCallsResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_QueryMembersRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_QueryMembersResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_SendEventRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_SendEventResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_GetCallStatsRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_ReportIssueRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_ReportIssueResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_ReviewCallRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_ReviewCallResponse: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "stream.video.coordinator.client_v1_rpc"

extension Stream_Video_Coordinator_ClientV1Rpc_MemberField: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "MEMBER_FIELD_UNSPECIFIED"),
        1: .same(proto: "MEMBER_FIELD_ROLE"),
        2: .same(proto: "MEMBER_FIELD_CUSTOM")
    ]
}

extension Stream_Video_Coordinator_ClientV1Rpc_UserEventType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "USER_EVENT_TYPE_UNSPECIFIED"),
        1: .same(proto: "USER_EVENT_TYPE_ACCEPTED_CALL"),
        2: .same(proto: "USER_EVENT_TYPE_REJECTED_CALL"),
        3: .same(proto: "USER_EVENT_TYPE_CANCELLED_CALL")
    ]
}

extension Stream_Video_Coordinator_ClientV1Rpc_GetCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_GetCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetCallResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._call {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallResponse
    ) -> Bool {
        if lhs._call != rhs._call { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_MemberInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".MemberInput"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "role"),
        2: .standard(proto: "custom_json")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.role) }()
            case 2: try { try decoder.decodeSingularBytesField(value: &self.customJson) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !role.isEmpty {
            try visitor.visitSingularStringField(value: role, fieldNumber: 1)
        }
        if !customJson.isEmpty {
            try visitor.visitSingularBytesField(value: customJson, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_MemberInput,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_MemberInput
    ) -> Bool {
        if lhs.role != rhs.role { return false }
        if lhs.customJson != rhs.customJson { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_UpdateCallMembersRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateCallMembersRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .same(proto: "members"),
        3: .same(proto: "fields")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf
                        ._ProtobufMessageMap<SwiftProtobuf.ProtobufString, Stream_Video_Coordinator_ClientV1Rpc_MemberInput>.self,
                    value: &self.members
                ) }()
            case 3: try { try decoder.decodeRepeatedEnumField(value: &self.fields) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        if !members.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf
                    ._ProtobufMessageMap<SwiftProtobuf.ProtobufString, Stream_Video_Coordinator_ClientV1Rpc_MemberInput>.self,
                value: members,
                fieldNumber: 2
            )
        }
        if !fields.isEmpty {
            try visitor.visitPackedEnumField(value: fields, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallMembersRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallMembersRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs.members != rhs.members { return false }
        if lhs.fields != rhs.fields { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_UpdateCallMembersResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateCallMembersResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallMembersResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallMembersResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeleteCallMembersRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .standard(proto: "user_ids")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        if !userIds.isEmpty {
            try visitor.visitRepeatedStringField(value: userIds, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs.userIds != rhs.userIds { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeleteCallMembersResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateCallInput"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call"),
        2: .same(proto: "members"),
        4: .same(proto: "ring")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
            case 2: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf
                        ._ProtobufMessageMap<SwiftProtobuf.ProtobufString, Stream_Video_Coordinator_ClientV1Rpc_MemberInput>.self,
                    value: &self.members
                ) }()
            case 4: try { try decoder.decodeSingularBoolField(value: &self._ring) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._call {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !members.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf
                    ._ProtobufMessageMap<SwiftProtobuf.ProtobufString, Stream_Video_Coordinator_ClientV1Rpc_MemberInput>.self,
                value: members,
                fieldNumber: 2
            )
        }
        try { if let v = self._ring {
            try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput
    ) -> Bool {
        if lhs._call != rhs._call { return false }
        if lhs.members != rhs.members { return false }
        if lhs._ring != rhs._ring { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_CreateCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "id"),
        3: .same(proto: "input")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self._id) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._input) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 1)
        }
        try { if let v = self._id {
            try visitor.visitSingularStringField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._input {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_CreateCallRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_CreateCallRequest
    ) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs._id != rhs._id { return false }
        if lhs._input != rhs._input { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetOrCreateCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "id"),
        3: .same(proto: "input")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._input) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 1)
        }
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 2)
        }
        try { if let v = self._input {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallRequest
    ) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.id != rhs.id { return false }
        if lhs._input != rhs._input { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_JoinCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".JoinCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "id"),
        3: .same(proto: "input"),
        4: .standard(proto: "datacenter_id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._input) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self.datacenterID) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 1)
        }
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 2)
        }
        try { if let v = self._input {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        if !datacenterID.isEmpty {
            try visitor.visitSingularStringField(value: datacenterID, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_JoinCallRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_JoinCallRequest
    ) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.id != rhs.id { return false }
        if lhs._input != rhs._input { return false }
        if lhs.datacenterID != rhs.datacenterID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_JoinCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".JoinCallResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call"),
        2: .same(proto: "created"),
        3: .same(proto: "edges")
    ]

    fileprivate class _StorageClass {
        var _call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope?
        var _created: Bool = false
        var _edges: [Stream_Video_Coordinator_EdgeV1_Edge] = []

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _call = source._call
            _created = source._created
            _edges = source._edges
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try { try decoder.decodeSingularMessageField(value: &_storage._call) }()
                case 2: try { try decoder.decodeSingularBoolField(value: &_storage._created) }()
                case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._edges) }()
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._call {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            if _storage._created != false {
                try visitor.visitSingularBoolField(value: _storage._created, fieldNumber: 2)
            }
            if !_storage._edges.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._edges, fieldNumber: 3)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_JoinCallResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_JoinCallResponse
    ) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool =
                withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                    let _storage = _args.0
                    let rhs_storage = _args.1
                    if _storage._call != rhs_storage._call { return false }
                    if _storage._created != rhs_storage._created { return false }
                    if _storage._edges != rhs_storage._edges { return false }
                    return true
                }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_CallInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CallInput"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "custom_json"),
        2: .same(proto: "options")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBytesField(value: &self.customJson) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._options) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !customJson.isEmpty {
            try visitor.visitSingularBytesField(value: customJson, fieldNumber: 1)
        }
        try { if let v = self._options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_CallInput,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_CallInput
    ) -> Bool {
        if lhs.customJson != rhs.customJson { return false }
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetOrCreateCallResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call"),
        2: .same(proto: "created")
    ]

    fileprivate class _StorageClass {
        var _call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope?
        var _created: Bool = false

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _call = source._call
            _created = source._created
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try { try decoder.decodeSingularMessageField(value: &_storage._call) }()
                case 2: try { try decoder.decodeSingularBoolField(value: &_storage._created) }()
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._call {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            if _storage._created != false {
                try visitor.visitSingularBoolField(value: _storage._created, fieldNumber: 2)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallResponse
    ) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool =
                withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                    let _storage = _args.0
                    let rhs_storage = _args.1
                    if _storage._call != rhs_storage._call { return false }
                    if _storage._created != rhs_storage._created { return false }
                    return true
                }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_UpdateCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .same(proto: "input")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._input) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        try { if let v = self._input {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs._input != rhs._input { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_UpdateCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateCallResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._call {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallResponse
    ) -> Bool {
        if lhs._call != rhs._call { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_CreateCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateCallResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._call {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_CreateCallResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_CreateCallResponse
    ) -> Bool {
        if lhs._call != rhs._call { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_QueryCallsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".QueryCallsRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "mq_json"),
        2: .same(proto: "limit"),
        3: .same(proto: "sorts")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBytesField(value: &self.mqJson) }()
            case 2: try { try decoder.decodeSingularInt32Field(value: &self._limit) }()
            case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sorts) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !mqJson.isEmpty {
            try visitor.visitSingularBytesField(value: mqJson, fieldNumber: 1)
        }
        try { if let v = self._limit {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
        } }()
        if !sorts.isEmpty {
            try visitor.visitRepeatedMessageField(value: sorts, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_QueryCallsRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_QueryCallsRequest
    ) -> Bool {
        if lhs.mqJson != rhs.mqJson { return false }
        if lhs._limit != rhs._limit { return false }
        if lhs.sorts != rhs.sorts { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_QueryCallsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".QueryCallsResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "calls")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._calls) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._calls {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_QueryCallsResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_QueryCallsResponse
    ) -> Bool {
        if lhs._calls != rhs._calls { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_QueryMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".QueryMembersRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "mq_json"),
        2: .same(proto: "limit"),
        3: .same(proto: "sorts")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBytesField(value: &self.mqJson) }()
            case 2: try { try decoder.decodeSingularInt32Field(value: &self._limit) }()
            case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sorts) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !mqJson.isEmpty {
            try visitor.visitSingularBytesField(value: mqJson, fieldNumber: 1)
        }
        try { if let v = self._limit {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
        } }()
        if !sorts.isEmpty {
            try visitor.visitRepeatedMessageField(value: sorts, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_QueryMembersRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_QueryMembersRequest
    ) -> Bool {
        if lhs.mqJson != rhs.mqJson { return false }
        if lhs._limit != rhs._limit { return false }
        if lhs.sorts != rhs.sorts { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_QueryMembersResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".QueryMembersResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "members")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._members) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._members {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_QueryMembersResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_QueryMembersResponse
    ) -> Bool {
        if lhs._members != rhs._members { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetCallEdgeServerRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .same(proto: "measurements")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._measurements) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        try { if let v = self._measurements {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs._measurements != rhs._measurements { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetCallEdgeServerResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call"),
        2: .same(proto: "credentials")
    ]

    fileprivate class _StorageClass {
        var _call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope?
        var _credentials: Stream_Video_Coordinator_EdgeV1_Credentials?

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _call = source._call
            _credentials = source._credentials
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try { try decoder.decodeSingularMessageField(value: &_storage._call) }()
                case 2: try { try decoder.decodeSingularMessageField(value: &_storage._credentials) }()
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._call {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            try { if let v = _storage._credentials {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerResponse
    ) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool =
                withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                    let _storage = _args.0
                    let rhs_storage = _args.1
                    if _storage._call != rhs_storage._call { return false }
                    if _storage._credentials != rhs_storage._credentials { return false }
                    return true
                }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateDeviceRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "input")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._input) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._input {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceRequest
    ) -> Bool {
        if lhs._input != rhs._input { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateDeviceResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "device")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._device {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceResponse
    ) -> Bool {
        if lhs._device != rhs._device { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeleteDeviceRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceRequest
    ) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeleteDeviceResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".QueryDevicesRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesRequest
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".QueryDevicesResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "devices")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !devices.isEmpty {
            try visitor.visitRepeatedMessageField(value: devices, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesResponse
    ) -> Bool {
        if lhs.devices != rhs.devices { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_SendEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SendEventRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .standard(proto: "event_type")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeSingularEnumField(value: &self.eventType) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        if eventType != .unspecified {
            try visitor.visitSingularEnumField(value: eventType, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_SendEventRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_SendEventRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs.eventType != rhs.eventType { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_SendEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SendEventResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_SendEventResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_SendEventResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SendCustomEventRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .same(proto: "type"),
        3: .standard(proto: "data_json")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
            case 3: try { try decoder.decodeSingularBytesField(value: &self.dataJson) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 2)
        }
        if !dataJson.isEmpty {
            try visitor.visitSingularBytesField(value: dataJson, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs.type != rhs.type { return false }
        if lhs.dataJson != rhs.dataJson { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SendCustomEventResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReportCallStatsRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type"),
        2: .standard(proto: "call_id"),
        3: .standard(proto: "stats_json")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            case 3: try { try decoder.decodeSingularBytesField(value: &self.statsJson) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 2)
        }
        if !statsJson.isEmpty {
            try visitor.visitSingularBytesField(value: statsJson, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsRequest
    ) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs.statsJson != rhs.statsJson { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReportCallStatsResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_GetCallStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetCallStatsRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type"),
        2: .standard(proto: "call_id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallStatsRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallStatsRequest
    ) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_ReportIssueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReportIssueRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type"),
        2: .standard(proto: "call_id"),
        3: .same(proto: "description"),
        4: .standard(proto: "custom_json")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
            case 4: try { try decoder.decodeSingularBytesField(value: &self.customJson) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 2)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 3)
        }
        if !customJson.isEmpty {
            try visitor.visitSingularBytesField(value: customJson, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_ReportIssueRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_ReportIssueRequest
    ) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.customJson != rhs.customJson { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_ReportIssueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReportIssueResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_ReportIssueResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_ReportIssueResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_ReviewCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReviewCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type"),
        2: .standard(proto: "call_id"),
        3: .same(proto: "stars"),
        4: .same(proto: "description"),
        5: .standard(proto: "custom_json")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            case 3: try { try decoder.decodeSingularFloatField(value: &self.stars) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
            case 5: try { try decoder.decodeSingularBytesField(value: &self.customJson) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 2)
        }
        if stars != 0 {
            try visitor.visitSingularFloatField(value: stars, fieldNumber: 3)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 4)
        }
        if !customJson.isEmpty {
            try visitor.visitSingularBytesField(value: customJson, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_ReviewCallRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_ReviewCallRequest
    ) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs.stars != rhs.stars { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.customJson != rhs.customJson { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_ReviewCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReviewCallResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_ReviewCallResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_ReviewCallResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
