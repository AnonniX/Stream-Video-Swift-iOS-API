//
// Copyright Â© 2022 Stream.io Inc. All rights reserved.
//

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

enum Stream_Video_Codec: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case h264Unspecified // = 0
    case vp8 // = 1
    case vp9 // = 2
    case UNRECOGNIZED(Int)

    init() {
        self = .h264Unspecified
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .h264Unspecified
        case 1: self = .vp8
        case 2: self = .vp9
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .h264Unspecified: return 0
        case .vp8: return 1
        case .vp9: return 2
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

extension Stream_Video_Codec: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Stream_Video_Codec] = [
        .h264Unspecified,
        .vp8,
        .vp9
    ]
}

#endif // swift(>=4.2)

enum Stream_Video_RecordingStorage: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case s3Unspecified // = 0
    case UNRECOGNIZED(Int)

    init() {
        self = .s3Unspecified
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .s3Unspecified
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .s3Unspecified: return 0
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

extension Stream_Video_RecordingStorage: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Stream_Video_RecordingStorage] = [
        .s3Unspecified
    ]
}

#endif // swift(>=4.2)

enum Stream_Video_Action: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case emptyUnspecified // = 0
    case createCall // = 1
    case deleteCall // = 2
    case screenshare // = 3
    case recordCall // = 4
    case startTranscribe // = 5
    case renameUser // = 6
    case hideProfilePictures // = 7
    case unmute // = 8
    case muteOtherUser // = 9
    case startVideo // = 10
    case broadcastCall // = 11
    case UNRECOGNIZED(Int)

    init() {
        self = .emptyUnspecified
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .emptyUnspecified
        case 1: self = .createCall
        case 2: self = .deleteCall
        case 3: self = .screenshare
        case 4: self = .recordCall
        case 5: self = .startTranscribe
        case 6: self = .renameUser
        case 7: self = .hideProfilePictures
        case 8: self = .unmute
        case 9: self = .muteOtherUser
        case 10: self = .startVideo
        case 11: self = .broadcastCall
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .emptyUnspecified: return 0
        case .createCall: return 1
        case .deleteCall: return 2
        case .screenshare: return 3
        case .recordCall: return 4
        case .startTranscribe: return 5
        case .renameUser: return 6
        case .hideProfilePictures: return 7
        case .unmute: return 8
        case .muteOtherUser: return 9
        case .startVideo: return 10
        case .broadcastCall: return 11
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

extension Stream_Video_Action: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Stream_Video_Action] = [
        .emptyUnspecified,
        .createCall,
        .deleteCall,
        .screenshare,
        .recordCall,
        .startTranscribe,
        .renameUser,
        .hideProfilePictures,
        .unmute,
        .muteOtherUser,
        .startVideo,
        .broadcastCall
    ]
}

#endif // swift(>=4.2)

enum Stream_Video_FeatureToggle: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// the feature is available and enabled by default
    case featureFlagEnabledUnspecified // = 0

    /// the feature is available but needs to be turned on the call level
    case featureFlagAvailable // = 1

    /// the feature is disabled and cannot be turned on
    case featureFlagDisabled // = 2
    case UNRECOGNIZED(Int)

    init() {
        self = .featureFlagEnabledUnspecified
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .featureFlagEnabledUnspecified
        case 1: self = .featureFlagAvailable
        case 2: self = .featureFlagDisabled
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .featureFlagEnabledUnspecified: return 0
        case .featureFlagAvailable: return 1
        case .featureFlagDisabled: return 2
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

extension Stream_Video_FeatureToggle: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Stream_Video_FeatureToggle] = [
        .featureFlagEnabledUnspecified,
        .featureFlagAvailable,
        .featureFlagDisabled
    ]
}

#endif // swift(>=4.2)

/// Edges are where we deploy video servers
struct Stream_Video_Edge {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var latencyURL: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// Edges are where we deploy video servers
struct Stream_Video_EdgeServer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var url: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Returns information about the server location
    struct Coordinates {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var lat: Float = 0

        var long: Float = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
    }

    init() {}
}

struct Stream_Video_Latency {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var measurementsSeconds: [Float] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_File {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: String = String()

    var composite: Bool = false

    var userID: String = String()

    var url: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_RecordBroadcast {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// if true merge all audio and video, if false split them
    var composite: Bool = false

    var files: [Stream_Video_File] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_User {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var teams: [String] = []

    var role: String = String()

    var custom: SwiftProtobuf.Google_Protobuf_Struct {
        get { _custom ?? SwiftProtobuf.Google_Protobuf_Struct() }
        set { _custom = newValue }
    }

    /// Returns true if `custom` has been explicitly set.
    var hasCustom: Bool { self._custom != nil }
    /// Clears the value of `custom`. Subsequent reads from it will return its default value.
    mutating func clearCustom() { _custom = nil }

    var name: String = String()

    var imageURL: String = String()

    /// user creation date as RFC3339 string
    var createdAt: String = String()

    /// user last update date as RFC3339 string
    var updatedAt: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct?
}

struct Stream_Video_UserRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var teams: [String] = []

    var role: String = String()

    var custom: SwiftProtobuf.Google_Protobuf_Struct {
        get { _custom ?? SwiftProtobuf.Google_Protobuf_Struct() }
        set { _custom = newValue }
    }

    /// Returns true if `custom` has been explicitly set.
    var hasCustom: Bool { self._custom != nil }
    /// Clears the value of `custom`. Subsequent reads from it will return its default value.
    mutating func clearCustom() { _custom = nil }

    var name: String = String()

    var profileImageURL: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct?
}

struct Stream_Video_Device {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: String = String()

    var id: String = String()

    var disabled: Bool = false

    var disabledReason: String = String()

    var pushProviderName: String = String()

    var createdAt: String = String()

    var updatedAt: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_DeviceRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: String = String()

    var id: String = String()

    var disabled: Bool = false

    var disabledReason: String = String()

    var pushProviderName: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_RecordingStorageOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var storage: Stream_Video_RecordingStorage = .s3Unspecified

    var accessKey: String = String()

    var secretKey: String = String()

    var bucketName: String = String()

    var region: String = String()

    var path: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_RTMPOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var urls: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Broadcast {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rtmp: Stream_Video_RTMPOptions {
        get { _rtmp ?? Stream_Video_RTMPOptions() }
        set { _rtmp = newValue }
    }

    /// Returns true if `rtmp` has been explicitly set.
    var hasRtmp: Bool { self._rtmp != nil }
    /// Clears the value of `rtmp`. Subsequent reads from it will return its default value.
    mutating func clearRtmp() { _rtmp = nil }

    var hlsURL: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _rtmp: Stream_Video_RTMPOptions?
}

struct Stream_Video_TranscribeOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Permission {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the unique permission identifier
    var id: String = String()

    /// the human readable version of the permission
    var name: String = String()

    /// the description of the permission
    var description_p: String = String()

    /// the action that this permission grants
    var action: Stream_Video_Action = .emptyUnspecified

    /// if true, the permission only applies if the user is the owner of the resource (eg. the creator of a call)
    var owner: Bool = false

    /// if true, the permission only applies if user and resource are from the same team
    var sameTeam: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Permissions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var permissions: [Stream_Video_Permission] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Grant {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callType: String = String()

    /// if provided we store this at the call level and merge with call_type
    var callID: String = String()

    var role: String = String()

    var actions: [Stream_Video_Action] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Features {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// recording calls
    var recording: Stream_Video_FeatureToggle = .featureFlagEnabledUnspecified

    /// HLS stream broadcast
    var hlsBroadcast: Stream_Video_FeatureToggle = .featureFlagEnabledUnspecified

    /// call transcription
    var transcribe: Stream_Video_FeatureToggle = .featureFlagEnabledUnspecified

    var transcribeOptions: Stream_Video_TranscribeOptions {
        get { _transcribeOptions ?? Stream_Video_TranscribeOptions() }
        set { _transcribeOptions = newValue }
    }

    /// Returns true if `transcribeOptions` has been explicitly set.
    var hasTranscribeOptions: Bool { self._transcribeOptions != nil }
    /// Clears the value of `transcribeOptions`. Subsequent reads from it will return its default value.
    mutating func clearTranscribeOptions() { _transcribeOptions = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _transcribeOptions: Stream_Video_TranscribeOptions?
}

struct Stream_Video_CallType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the unique name for the call type
    var name: String = String()

    /// the permissions set for this call type
    var permissions: [String: Stream_Video_Permissions] = [:]

    /// the features enabled by default for this type of calls
    var features: Stream_Video_Features {
        get { _features ?? Stream_Video_Features() }
        set { _features = newValue }
    }

    /// Returns true if `features` has been explicitly set.
    var hasFeatures: Bool { self._features != nil }
    /// Clears the value of `features`. Subsequent reads from it will return its default value.
    mutating func clearFeatures() { _features = nil }

    var createdAt: String = String()

    var updatedAt: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _features: Stream_Video_Features?
}

/// those who are online in the call
struct Stream_Video_Participant {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var user: Stream_Video_User {
        get { _user ?? Stream_Video_User() }
        set { _user = newValue }
    }

    /// Returns true if `user` has been explicitly set.
    var hasUser: Bool { self._user != nil }
    /// Clears the value of `user`. Subsequent reads from it will return its default value.
    mutating func clearUser() { _user = nil }

    var role: String = String()

    var online: Bool = false

    var custom: SwiftProtobuf.Google_Protobuf_Struct {
        get { _custom ?? SwiftProtobuf.Google_Protobuf_Struct() }
        set { _custom = newValue }
    }

    /// Returns true if `custom` has been explicitly set.
    var hasCustom: Bool { self._custom != nil }
    /// Clears the value of `custom`. Subsequent reads from it will return its default value.
    mutating func clearCustom() { _custom = nil }

    var video: Bool = false

    var audio: Bool = false

    /// call creation date as RFC3339 string
    var createdAt: String = String()

    /// call last update date as RFC3339 string
    var updatedAt: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _user: Stream_Video_User?
    fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct?
}

struct Stream_Video_ParticipantRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: String = String()

    var role: String = String()

    /// call custom data
    var custom: SwiftProtobuf.Google_Protobuf_Struct {
        get { _custom ?? SwiftProtobuf.Google_Protobuf_Struct() }
        set { _custom = newValue }
    }

    /// Returns true if `custom` has been explicitly set.
    var hasCustom: Bool { self._custom != nil }
    /// Clears the value of `custom`. Subsequent reads from it will return its default value.
    mutating func clearCustom() { _custom = nil }

    /// call creation date as RFC3339 string
    var createdAt: String = String()

    /// call last update date as RFC3339 string
    var updatedAt: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct?
}

struct Stream_Video_CallState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var participants: [Stream_Video_Participant] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Call {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the call type
    var type: String = String()

    /// the call id
    var id: String = String()

    /// the id of the user that created this call
    var createdByUserID: String = String()

    /// the id of the current host for this call
    var hostUserID: String = String()

    var custom: SwiftProtobuf.Google_Protobuf_Struct {
        get { _custom ?? SwiftProtobuf.Google_Protobuf_Struct() }
        set { _custom = newValue }
    }

    /// Returns true if `custom` has been explicitly set.
    var hasCustom: Bool { self._custom != nil }
    /// Clears the value of `custom`. Subsequent reads from it will return its default value.
    mutating func clearCustom() { _custom = nil }

    /// call creation date as RFC3339 string
    var createdAt: String = String()

    /// call last update date as RFC3339 string
    var updatedAt: String = String()

    /// when recording is true, calls are recorded on S3
    var recording: Bool = false

    /// broadcast settings for this call
    var broadcast: Stream_Video_Broadcast {
        get { _broadcast ?? Stream_Video_Broadcast() }
        set { _broadcast = newValue }
    }

    /// Returns true if `broadcast` has been explicitly set.
    var hasBroadcast: Bool { self._broadcast != nil }
    /// Clears the value of `broadcast`. Subsequent reads from it will return its default value.
    mutating func clearBroadcast() { _broadcast = nil }

    /// enable transcription by default
    var transcribe: Bool = false

    var transcribeOptions: Stream_Video_TranscribeOptions {
        get { _transcribeOptions ?? Stream_Video_TranscribeOptions() }
        set { _transcribeOptions = newValue }
    }

    /// Returns true if `transcribeOptions` has been explicitly set.
    var hasTranscribeOptions: Bool { self._transcribeOptions != nil }
    /// Clears the value of `transcribeOptions`. Subsequent reads from it will return its default value.
    mutating func clearTranscribeOptions() { _transcribeOptions = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct?
    private var _broadcast: Stream_Video_Broadcast?
    fileprivate var _transcribeOptions: Stream_Video_TranscribeOptions?
}

struct Stream_Video_ApnSettings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var authKey: String = String()

    var keyID: String = String()

    var apnTopic: String = String()

    var teamID: String = String()

    var development: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_FirebaseSettings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var serverKey: String = String()

    var credentialsJson: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_HuaweiSettings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var secret: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_XiaomiSettings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var packageName: String = String()

    var secret: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_SqsSettings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var url: String = String()

    var key: String = String()

    var secret: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_PushProvider {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the name for this push provider, unique for this application
    /// @example apn_production
    /// @example firebase_staging
    var name: String = String()

    var settings: Stream_Video_PushProvider.OneOf_Settings?

    /// apn push configs
    var apnSettings: Stream_Video_ApnSettings {
        get {
            if case let .apnSettings(v)? = settings { return v }
            return Stream_Video_ApnSettings()
        }
        set { settings = .apnSettings(newValue) }
    }

    /// firebase push configs
    var firebaseSettings: Stream_Video_FirebaseSettings {
        get {
            if case let .firebaseSettings(v)? = settings { return v }
            return Stream_Video_FirebaseSettings()
        }
        set { settings = .firebaseSettings(newValue) }
    }

    /// huawei push configs
    var huaweiSettings: Stream_Video_HuaweiSettings {
        get {
            if case let .huaweiSettings(v)? = settings { return v }
            return Stream_Video_HuaweiSettings()
        }
        set { settings = .huaweiSettings(newValue) }
    }

    /// xiaomi push configs
    var xiaomiSettings: Stream_Video_XiaomiSettings {
        get {
            if case let .xiaomiSettings(v)? = settings { return v }
            return Stream_Video_XiaomiSettings()
        }
        set { settings = .xiaomiSettings(newValue) }
    }

    var disabled: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Settings: Equatable {
        /// apn push configs
        case apnSettings(Stream_Video_ApnSettings)
        /// firebase push configs
        case firebaseSettings(Stream_Video_FirebaseSettings)
        /// huawei push configs
        case huaweiSettings(Stream_Video_HuaweiSettings)
        /// xiaomi push configs
        case xiaomiSettings(Stream_Video_XiaomiSettings)

        #if !swift(>=4.1)
        static func == (lhs: Stream_Video_PushProvider.OneOf_Settings, rhs: Stream_Video_PushProvider.OneOf_Settings) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.apnSettings, .apnSettings): return {
                    guard case let .apnSettings(l) = lhs, case let .apnSettings(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.firebaseSettings, .firebaseSettings): return {
                    guard case let .firebaseSettings(l) = lhs, case let .firebaseSettings(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.huaweiSettings, .huaweiSettings): return {
                    guard case let .huaweiSettings(l) = lhs, case let .huaweiSettings(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.xiaomiSettings, .xiaomiSettings): return {
                    guard case let .xiaomiSettings(l) = lhs, case let .xiaomiSettings(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            default: return false
            }
        }
        #endif
    }

    init() {}
}

struct Stream_Video_ApplicationSettings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the webhook URL
    var webhookURL: String = String()

    /// push providers configured
    var pushProviders: [Stream_Video_PushProvider] = []

    /// sqs settings
    var sqsSettings: Stream_Video_SqsSettings {
        get { _sqsSettings ?? Stream_Video_SqsSettings() }
        set { _sqsSettings = newValue }
    }

    /// Returns true if `sqsSettings` has been explicitly set.
    var hasSqsSettings: Bool { self._sqsSettings != nil }
    /// Clears the value of `sqsSettings`. Subsequent reads from it will return its default value.
    mutating func clearSqsSettings() { _sqsSettings = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _sqsSettings: Stream_Video_SqsSettings?
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stream_Video_Codec: @unchecked Sendable {}
extension Stream_Video_RecordingStorage: @unchecked Sendable {}
extension Stream_Video_Action: @unchecked Sendable {}
extension Stream_Video_FeatureToggle: @unchecked Sendable {}
extension Stream_Video_Edge: @unchecked Sendable {}
extension Stream_Video_EdgeServer: @unchecked Sendable {}
extension Stream_Video_EdgeServer.Coordinates: @unchecked Sendable {}
extension Stream_Video_Latency: @unchecked Sendable {}
extension Stream_Video_File: @unchecked Sendable {}
extension Stream_Video_RecordBroadcast: @unchecked Sendable {}
extension Stream_Video_User: @unchecked Sendable {}
extension Stream_Video_UserRequest: @unchecked Sendable {}
extension Stream_Video_Device: @unchecked Sendable {}
extension Stream_Video_DeviceRequest: @unchecked Sendable {}
extension Stream_Video_RecordingStorageOptions: @unchecked Sendable {}
extension Stream_Video_RTMPOptions: @unchecked Sendable {}
extension Stream_Video_Broadcast: @unchecked Sendable {}
extension Stream_Video_TranscribeOptions: @unchecked Sendable {}
extension Stream_Video_Permission: @unchecked Sendable {}
extension Stream_Video_Permissions: @unchecked Sendable {}
extension Stream_Video_Grant: @unchecked Sendable {}
extension Stream_Video_Features: @unchecked Sendable {}
extension Stream_Video_CallType: @unchecked Sendable {}
extension Stream_Video_Participant: @unchecked Sendable {}
extension Stream_Video_ParticipantRequest: @unchecked Sendable {}
extension Stream_Video_CallState: @unchecked Sendable {}
extension Stream_Video_Call: @unchecked Sendable {}
extension Stream_Video_ApnSettings: @unchecked Sendable {}
extension Stream_Video_FirebaseSettings: @unchecked Sendable {}
extension Stream_Video_HuaweiSettings: @unchecked Sendable {}
extension Stream_Video_XiaomiSettings: @unchecked Sendable {}
extension Stream_Video_SqsSettings: @unchecked Sendable {}
extension Stream_Video_PushProvider: @unchecked Sendable {}
extension Stream_Video_PushProvider.OneOf_Settings: @unchecked Sendable {}
extension Stream_Video_ApplicationSettings: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "stream.video"

extension Stream_Video_Codec: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "CODEC_H264_UNSPECIFIED"),
        1: .same(proto: "CODEC_VP8"),
        2: .same(proto: "CODEC_VP9")
    ]
}

extension Stream_Video_RecordingStorage: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "RECORDING_STORAGE_S3_UNSPECIFIED")
    ]
}

extension Stream_Video_Action: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "ACTION_EMPTY_UNSPECIFIED"),
        1: .same(proto: "ACTION_CREATE_CALL"),
        2: .same(proto: "ACTION_DELETE_CALL"),
        3: .same(proto: "ACTION_SCREENSHARE"),
        4: .same(proto: "ACTION_RECORD_CALL"),
        5: .same(proto: "ACTION_START_TRANSCRIBE"),
        6: .same(proto: "ACTION_RENAME_USER"),
        7: .same(proto: "ACTION_HIDE_PROFILE_PICTURES"),
        8: .same(proto: "ACTION_UNMUTE"),
        9: .same(proto: "ACTION_MUTE_OTHER_USER"),
        10: .same(proto: "ACTION_START_VIDEO"),
        11: .same(proto: "ACTION_BROADCAST_CALL")
    ]
}

extension Stream_Video_FeatureToggle: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "FEATURE_TOGGLE_FEATURE_FLAG_ENABLED_UNSPECIFIED"),
        1: .same(proto: "FEATURE_TOGGLE_FEATURE_FLAG_AVAILABLE"),
        2: .same(proto: "FEATURE_TOGGLE_FEATURE_FLAG_DISABLED")
    ]
}

extension Stream_Video_Edge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Edge"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .standard(proto: "latency_url")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.latencyURL) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if !latencyURL.isEmpty {
            try visitor.visitSingularStringField(value: latencyURL, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Edge, rhs: Stream_Video_Edge) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.latencyURL != rhs.latencyURL { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_EdgeServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".EdgeServer"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "url")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !url.isEmpty {
            try visitor.visitSingularStringField(value: url, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_EdgeServer, rhs: Stream_Video_EdgeServer) -> Bool {
        if lhs.url != rhs.url { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_EdgeServer.Coordinates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Stream_Video_EdgeServer.protoMessageName + ".Coordinates"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "lat"),
        2: .same(proto: "long")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularFloatField(value: &self.lat) }()
            case 2: try { try decoder.decodeSingularFloatField(value: &self.long) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if lat != 0 {
            try visitor.visitSingularFloatField(value: lat, fieldNumber: 1)
        }
        if long != 0 {
            try visitor.visitSingularFloatField(value: long, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_EdgeServer.Coordinates, rhs: Stream_Video_EdgeServer.Coordinates) -> Bool {
        if lhs.lat != rhs.lat { return false }
        if lhs.long != rhs.long { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Latency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Latency"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "measurements_seconds")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedFloatField(value: &self.measurementsSeconds) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !measurementsSeconds.isEmpty {
            try visitor.visitPackedFloatField(value: measurementsSeconds, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Latency, rhs: Stream_Video_Latency) -> Bool {
        if lhs.measurementsSeconds != rhs.measurementsSeconds { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".File"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "composite"),
        3: .standard(proto: "user_id"),
        4: .same(proto: "url")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.composite) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 1)
        }
        if composite != false {
            try visitor.visitSingularBoolField(value: composite, fieldNumber: 2)
        }
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 3)
        }
        if !url.isEmpty {
            try visitor.visitSingularStringField(value: url, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_File, rhs: Stream_Video_File) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.composite != rhs.composite { return false }
        if lhs.userID != rhs.userID { return false }
        if lhs.url != rhs.url { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_RecordBroadcast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RecordBroadcast"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "composite"),
        2: .same(proto: "files")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBoolField(value: &self.composite) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.files) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if composite != false {
            try visitor.visitSingularBoolField(value: composite, fieldNumber: 1)
        }
        if !files.isEmpty {
            try visitor.visitRepeatedMessageField(value: files, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_RecordBroadcast, rhs: Stream_Video_RecordBroadcast) -> Bool {
        if lhs.composite != rhs.composite { return false }
        if lhs.files != rhs.files { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".User"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "teams"),
        3: .same(proto: "role"),
        4: .same(proto: "custom"),
        5: .same(proto: "name"),
        6: .standard(proto: "image_url"),
        7: .standard(proto: "created_at"),
        8: .standard(proto: "updated_at")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 2: try { try decoder.decodeRepeatedStringField(value: &self.teams) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.role) }()
            case 4: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
            case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
            case 6: try { try decoder.decodeSingularStringField(value: &self.imageURL) }()
            case 7: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
            case 8: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !teams.isEmpty {
            try visitor.visitRepeatedStringField(value: teams, fieldNumber: 2)
        }
        if !role.isEmpty {
            try visitor.visitSingularStringField(value: role, fieldNumber: 3)
        }
        try { if let v = self._custom {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 5)
        }
        if !imageURL.isEmpty {
            try visitor.visitSingularStringField(value: imageURL, fieldNumber: 6)
        }
        if !createdAt.isEmpty {
            try visitor.visitSingularStringField(value: createdAt, fieldNumber: 7)
        }
        if !updatedAt.isEmpty {
            try visitor.visitSingularStringField(value: updatedAt, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_User, rhs: Stream_Video_User) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.teams != rhs.teams { return false }
        if lhs.role != rhs.role { return false }
        if lhs._custom != rhs._custom { return false }
        if lhs.name != rhs.name { return false }
        if lhs.imageURL != rhs.imageURL { return false }
        if lhs.createdAt != rhs.createdAt { return false }
        if lhs.updatedAt != rhs.updatedAt { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_UserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UserRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "teams"),
        3: .same(proto: "role"),
        4: .same(proto: "custom"),
        5: .same(proto: "name"),
        6: .standard(proto: "profile_image_url")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 2: try { try decoder.decodeRepeatedStringField(value: &self.teams) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.role) }()
            case 4: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
            case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
            case 6: try { try decoder.decodeSingularStringField(value: &self.profileImageURL) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !teams.isEmpty {
            try visitor.visitRepeatedStringField(value: teams, fieldNumber: 2)
        }
        if !role.isEmpty {
            try visitor.visitSingularStringField(value: role, fieldNumber: 3)
        }
        try { if let v = self._custom {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 5)
        }
        if !profileImageURL.isEmpty {
            try visitor.visitSingularStringField(value: profileImageURL, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_UserRequest, rhs: Stream_Video_UserRequest) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.teams != rhs.teams { return false }
        if lhs.role != rhs.role { return false }
        if lhs._custom != rhs._custom { return false }
        if lhs.name != rhs.name { return false }
        if lhs.profileImageURL != rhs.profileImageURL { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Device"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_id"),
        2: .same(proto: "id"),
        3: .same(proto: "disabled"),
        4: .standard(proto: "disabled_reason"),
        5: .standard(proto: "push_provider_name"),
        6: .standard(proto: "created_at"),
        7: .standard(proto: "updated_at")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self.disabledReason) }()
            case 5: try { try decoder.decodeSingularStringField(value: &self.pushProviderName) }()
            case 6: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
            case 7: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 1)
        }
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 2)
        }
        if disabled != false {
            try visitor.visitSingularBoolField(value: disabled, fieldNumber: 3)
        }
        if !disabledReason.isEmpty {
            try visitor.visitSingularStringField(value: disabledReason, fieldNumber: 4)
        }
        if !pushProviderName.isEmpty {
            try visitor.visitSingularStringField(value: pushProviderName, fieldNumber: 5)
        }
        if !createdAt.isEmpty {
            try visitor.visitSingularStringField(value: createdAt, fieldNumber: 6)
        }
        if !updatedAt.isEmpty {
            try visitor.visitSingularStringField(value: updatedAt, fieldNumber: 7)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Device, rhs: Stream_Video_Device) -> Bool {
        if lhs.userID != rhs.userID { return false }
        if lhs.id != rhs.id { return false }
        if lhs.disabled != rhs.disabled { return false }
        if lhs.disabledReason != rhs.disabledReason { return false }
        if lhs.pushProviderName != rhs.pushProviderName { return false }
        if lhs.createdAt != rhs.createdAt { return false }
        if lhs.updatedAt != rhs.updatedAt { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_DeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeviceRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_id"),
        2: .same(proto: "id"),
        3: .same(proto: "disabled"),
        4: .standard(proto: "disabled_reason"),
        5: .standard(proto: "push_provider_name")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self.disabledReason) }()
            case 5: try { try decoder.decodeSingularStringField(value: &self.pushProviderName) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 1)
        }
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 2)
        }
        if disabled != false {
            try visitor.visitSingularBoolField(value: disabled, fieldNumber: 3)
        }
        if !disabledReason.isEmpty {
            try visitor.visitSingularStringField(value: disabledReason, fieldNumber: 4)
        }
        if !pushProviderName.isEmpty {
            try visitor.visitSingularStringField(value: pushProviderName, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_DeviceRequest, rhs: Stream_Video_DeviceRequest) -> Bool {
        if lhs.userID != rhs.userID { return false }
        if lhs.id != rhs.id { return false }
        if lhs.disabled != rhs.disabled { return false }
        if lhs.disabledReason != rhs.disabledReason { return false }
        if lhs.pushProviderName != rhs.pushProviderName { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_RecordingStorageOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RecordingStorageOptions"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        2: .same(proto: "storage"),
        3: .standard(proto: "access_key"),
        4: .standard(proto: "secret_key"),
        5: .standard(proto: "bucket_name"),
        6: .same(proto: "region"),
        7: .same(proto: "path")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 2: try { try decoder.decodeSingularEnumField(value: &self.storage) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.accessKey) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self.secretKey) }()
            case 5: try { try decoder.decodeSingularStringField(value: &self.bucketName) }()
            case 6: try { try decoder.decodeSingularStringField(value: &self.region) }()
            case 7: try { try decoder.decodeSingularStringField(value: &self.path) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if storage != .s3Unspecified {
            try visitor.visitSingularEnumField(value: storage, fieldNumber: 2)
        }
        if !accessKey.isEmpty {
            try visitor.visitSingularStringField(value: accessKey, fieldNumber: 3)
        }
        if !secretKey.isEmpty {
            try visitor.visitSingularStringField(value: secretKey, fieldNumber: 4)
        }
        if !bucketName.isEmpty {
            try visitor.visitSingularStringField(value: bucketName, fieldNumber: 5)
        }
        if !region.isEmpty {
            try visitor.visitSingularStringField(value: region, fieldNumber: 6)
        }
        if !path.isEmpty {
            try visitor.visitSingularStringField(value: path, fieldNumber: 7)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_RecordingStorageOptions, rhs: Stream_Video_RecordingStorageOptions) -> Bool {
        if lhs.storage != rhs.storage { return false }
        if lhs.accessKey != rhs.accessKey { return false }
        if lhs.secretKey != rhs.secretKey { return false }
        if lhs.bucketName != rhs.bucketName { return false }
        if lhs.region != rhs.region { return false }
        if lhs.path != rhs.path { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_RTMPOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RTMPOptions"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "urls")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedStringField(value: &self.urls) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !urls.isEmpty {
            try visitor.visitRepeatedStringField(value: urls, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_RTMPOptions, rhs: Stream_Video_RTMPOptions) -> Bool {
        if lhs.urls != rhs.urls { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Broadcast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Broadcast"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "rtmp"),
        2: .standard(proto: "hls_url")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._rtmp) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.hlsURL) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._rtmp {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !hlsURL.isEmpty {
            try visitor.visitSingularStringField(value: hlsURL, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Broadcast, rhs: Stream_Video_Broadcast) -> Bool {
        if lhs._rtmp != rhs._rtmp { return false }
        if lhs.hlsURL != rhs.hlsURL { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_TranscribeOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".TranscribeOptions"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_TranscribeOptions, rhs: Stream_Video_TranscribeOptions) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Permission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Permission"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "name"),
        3: .same(proto: "description"),
        4: .same(proto: "action"),
        5: .same(proto: "owner"),
        6: .standard(proto: "same_team")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
            case 4: try { try decoder.decodeSingularEnumField(value: &self.action) }()
            case 5: try { try decoder.decodeSingularBoolField(value: &self.owner) }()
            case 6: try { try decoder.decodeSingularBoolField(value: &self.sameTeam) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 2)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 3)
        }
        if action != .emptyUnspecified {
            try visitor.visitSingularEnumField(value: action, fieldNumber: 4)
        }
        if owner != false {
            try visitor.visitSingularBoolField(value: owner, fieldNumber: 5)
        }
        if sameTeam != false {
            try visitor.visitSingularBoolField(value: sameTeam, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Permission, rhs: Stream_Video_Permission) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.name != rhs.name { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.action != rhs.action { return false }
        if lhs.owner != rhs.owner { return false }
        if lhs.sameTeam != rhs.sameTeam { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Permissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Permissions"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "permissions")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.permissions) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !permissions.isEmpty {
            try visitor.visitRepeatedMessageField(value: permissions, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Permissions, rhs: Stream_Video_Permissions) -> Bool {
        if lhs.permissions != rhs.permissions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Grant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Grant"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type"),
        2: .standard(proto: "call_id"),
        3: .same(proto: "role"),
        5: .same(proto: "actions")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.role) }()
            case 5: try { try decoder.decodeRepeatedEnumField(value: &self.actions) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 2)
        }
        if !role.isEmpty {
            try visitor.visitSingularStringField(value: role, fieldNumber: 3)
        }
        if !actions.isEmpty {
            try visitor.visitPackedEnumField(value: actions, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Grant, rhs: Stream_Video_Grant) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs.role != rhs.role { return false }
        if lhs.actions != rhs.actions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Features: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Features"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "recording"),
        3: .standard(proto: "hls_broadcast"),
        4: .same(proto: "transcribe"),
        5: .standard(proto: "transcribe_options")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularEnumField(value: &self.recording) }()
            case 3: try { try decoder.decodeSingularEnumField(value: &self.hlsBroadcast) }()
            case 4: try { try decoder.decodeSingularEnumField(value: &self.transcribe) }()
            case 5: try { try decoder.decodeSingularMessageField(value: &self._transcribeOptions) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if recording != .featureFlagEnabledUnspecified {
            try visitor.visitSingularEnumField(value: recording, fieldNumber: 1)
        }
        if hlsBroadcast != .featureFlagEnabledUnspecified {
            try visitor.visitSingularEnumField(value: hlsBroadcast, fieldNumber: 3)
        }
        if transcribe != .featureFlagEnabledUnspecified {
            try visitor.visitSingularEnumField(value: transcribe, fieldNumber: 4)
        }
        try { if let v = self._transcribeOptions {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Features, rhs: Stream_Video_Features) -> Bool {
        if lhs.recording != rhs.recording { return false }
        if lhs.hlsBroadcast != rhs.hlsBroadcast { return false }
        if lhs.transcribe != rhs.transcribe { return false }
        if lhs._transcribeOptions != rhs._transcribeOptions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_CallType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CallType"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "permissions"),
        3: .same(proto: "features"),
        4: .standard(proto: "created_at"),
        5: .standard(proto: "updated_at")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
            case 2: try { try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString, Stream_Video_Permissions>.self,
                    value: &self.permissions
                ) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._features) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
            case 5: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if !permissions.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString, Stream_Video_Permissions>.self,
                value: permissions,
                fieldNumber: 2
            )
        }
        try { if let v = self._features {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        if !createdAt.isEmpty {
            try visitor.visitSingularStringField(value: createdAt, fieldNumber: 4)
        }
        if !updatedAt.isEmpty {
            try visitor.visitSingularStringField(value: updatedAt, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_CallType, rhs: Stream_Video_CallType) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.permissions != rhs.permissions { return false }
        if lhs._features != rhs._features { return false }
        if lhs.createdAt != rhs.createdAt { return false }
        if lhs.updatedAt != rhs.updatedAt { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Participant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Participant"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "user"),
        2: .same(proto: "role"),
        3: .same(proto: "online"),
        4: .same(proto: "custom"),
        5: .same(proto: "video"),
        6: .same(proto: "audio"),
        7: .standard(proto: "created_at"),
        8: .standard(proto: "updated_at")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._user) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.role) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.online) }()
            case 4: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
            case 5: try { try decoder.decodeSingularBoolField(value: &self.video) }()
            case 6: try { try decoder.decodeSingularBoolField(value: &self.audio) }()
            case 7: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
            case 8: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._user {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !role.isEmpty {
            try visitor.visitSingularStringField(value: role, fieldNumber: 2)
        }
        if online != false {
            try visitor.visitSingularBoolField(value: online, fieldNumber: 3)
        }
        try { if let v = self._custom {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        if video != false {
            try visitor.visitSingularBoolField(value: video, fieldNumber: 5)
        }
        if audio != false {
            try visitor.visitSingularBoolField(value: audio, fieldNumber: 6)
        }
        if !createdAt.isEmpty {
            try visitor.visitSingularStringField(value: createdAt, fieldNumber: 7)
        }
        if !updatedAt.isEmpty {
            try visitor.visitSingularStringField(value: updatedAt, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Participant, rhs: Stream_Video_Participant) -> Bool {
        if lhs._user != rhs._user { return false }
        if lhs.role != rhs.role { return false }
        if lhs.online != rhs.online { return false }
        if lhs._custom != rhs._custom { return false }
        if lhs.video != rhs.video { return false }
        if lhs.audio != rhs.audio { return false }
        if lhs.createdAt != rhs.createdAt { return false }
        if lhs.updatedAt != rhs.updatedAt { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_ParticipantRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ParticipantRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_id"),
        2: .same(proto: "role"),
        3: .same(proto: "custom"),
        4: .standard(proto: "created_at"),
        5: .standard(proto: "updated_at")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.role) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
            case 5: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 1)
        }
        if !role.isEmpty {
            try visitor.visitSingularStringField(value: role, fieldNumber: 2)
        }
        try { if let v = self._custom {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        if !createdAt.isEmpty {
            try visitor.visitSingularStringField(value: createdAt, fieldNumber: 4)
        }
        if !updatedAt.isEmpty {
            try visitor.visitSingularStringField(value: updatedAt, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_ParticipantRequest, rhs: Stream_Video_ParticipantRequest) -> Bool {
        if lhs.userID != rhs.userID { return false }
        if lhs.role != rhs.role { return false }
        if lhs._custom != rhs._custom { return false }
        if lhs.createdAt != rhs.createdAt { return false }
        if lhs.updatedAt != rhs.updatedAt { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_CallState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CallState"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "participants")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.participants) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !participants.isEmpty {
            try visitor.visitRepeatedMessageField(value: participants, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_CallState, rhs: Stream_Video_CallState) -> Bool {
        if lhs.participants != rhs.participants { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Call: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Call"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "id"),
        3: .standard(proto: "created_by_user_id"),
        4: .standard(proto: "host_user_id"),
        5: .same(proto: "custom"),
        6: .standard(proto: "created_at"),
        7: .standard(proto: "updated_at"),
        8: .same(proto: "recording"),
        9: .same(proto: "broadcast"),
        10: .same(proto: "transcribe"),
        11: .standard(proto: "transcribe_options")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.createdByUserID) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self.hostUserID) }()
            case 5: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
            case 6: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
            case 7: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
            case 8: try { try decoder.decodeSingularBoolField(value: &self.recording) }()
            case 9: try { try decoder.decodeSingularMessageField(value: &self._broadcast) }()
            case 10: try { try decoder.decodeSingularBoolField(value: &self.transcribe) }()
            case 11: try { try decoder.decodeSingularMessageField(value: &self._transcribeOptions) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 1)
        }
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 2)
        }
        if !createdByUserID.isEmpty {
            try visitor.visitSingularStringField(value: createdByUserID, fieldNumber: 3)
        }
        if !hostUserID.isEmpty {
            try visitor.visitSingularStringField(value: hostUserID, fieldNumber: 4)
        }
        try { if let v = self._custom {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        if !createdAt.isEmpty {
            try visitor.visitSingularStringField(value: createdAt, fieldNumber: 6)
        }
        if !updatedAt.isEmpty {
            try visitor.visitSingularStringField(value: updatedAt, fieldNumber: 7)
        }
        if recording != false {
            try visitor.visitSingularBoolField(value: recording, fieldNumber: 8)
        }
        try { if let v = self._broadcast {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
        } }()
        if transcribe != false {
            try visitor.visitSingularBoolField(value: transcribe, fieldNumber: 10)
        }
        try { if let v = self._transcribeOptions {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Call, rhs: Stream_Video_Call) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.id != rhs.id { return false }
        if lhs.createdByUserID != rhs.createdByUserID { return false }
        if lhs.hostUserID != rhs.hostUserID { return false }
        if lhs._custom != rhs._custom { return false }
        if lhs.createdAt != rhs.createdAt { return false }
        if lhs.updatedAt != rhs.updatedAt { return false }
        if lhs.recording != rhs.recording { return false }
        if lhs._broadcast != rhs._broadcast { return false }
        if lhs.transcribe != rhs.transcribe { return false }
        if lhs._transcribeOptions != rhs._transcribeOptions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_ApnSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ApnSettings"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "auth_key"),
        2: .standard(proto: "key_id"),
        3: .standard(proto: "apn_topic"),
        4: .standard(proto: "team_id"),
        5: .same(proto: "development")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.authKey) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.apnTopic) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self.teamID) }()
            case 5: try { try decoder.decodeSingularBoolField(value: &self.development) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !authKey.isEmpty {
            try visitor.visitSingularStringField(value: authKey, fieldNumber: 1)
        }
        if !keyID.isEmpty {
            try visitor.visitSingularStringField(value: keyID, fieldNumber: 2)
        }
        if !apnTopic.isEmpty {
            try visitor.visitSingularStringField(value: apnTopic, fieldNumber: 3)
        }
        if !teamID.isEmpty {
            try visitor.visitSingularStringField(value: teamID, fieldNumber: 4)
        }
        if development != false {
            try visitor.visitSingularBoolField(value: development, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_ApnSettings, rhs: Stream_Video_ApnSettings) -> Bool {
        if lhs.authKey != rhs.authKey { return false }
        if lhs.keyID != rhs.keyID { return false }
        if lhs.apnTopic != rhs.apnTopic { return false }
        if lhs.teamID != rhs.teamID { return false }
        if lhs.development != rhs.development { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_FirebaseSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".FirebaseSettings"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "server_key"),
        2: .standard(proto: "credentials_json")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.serverKey) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.credentialsJson) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !serverKey.isEmpty {
            try visitor.visitSingularStringField(value: serverKey, fieldNumber: 1)
        }
        if !credentialsJson.isEmpty {
            try visitor.visitSingularStringField(value: credentialsJson, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_FirebaseSettings, rhs: Stream_Video_FirebaseSettings) -> Bool {
        if lhs.serverKey != rhs.serverKey { return false }
        if lhs.credentialsJson != rhs.credentialsJson { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_HuaweiSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".HuaweiSettings"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "secret")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.secret) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        if !secret.isEmpty {
            try visitor.visitSingularStringField(value: secret, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_HuaweiSettings, rhs: Stream_Video_HuaweiSettings) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.secret != rhs.secret { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_XiaomiSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".XiaomiSettings"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "package_name"),
        2: .same(proto: "secret")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.packageName) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.secret) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !packageName.isEmpty {
            try visitor.visitSingularStringField(value: packageName, fieldNumber: 1)
        }
        if !secret.isEmpty {
            try visitor.visitSingularStringField(value: secret, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_XiaomiSettings, rhs: Stream_Video_XiaomiSettings) -> Bool {
        if lhs.packageName != rhs.packageName { return false }
        if lhs.secret != rhs.secret { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_SqsSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SqsSettings"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "url"),
        2: .same(proto: "key"),
        3: .same(proto: "secret")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.secret) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !url.isEmpty {
            try visitor.visitSingularStringField(value: url, fieldNumber: 1)
        }
        if !key.isEmpty {
            try visitor.visitSingularStringField(value: key, fieldNumber: 2)
        }
        if !secret.isEmpty {
            try visitor.visitSingularStringField(value: secret, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_SqsSettings, rhs: Stream_Video_SqsSettings) -> Bool {
        if lhs.url != rhs.url { return false }
        if lhs.key != rhs.key { return false }
        if lhs.secret != rhs.secret { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_PushProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PushProvider"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .standard(proto: "apn_settings"),
        3: .standard(proto: "firebase_settings"),
        4: .standard(proto: "huawei_settings"),
        5: .standard(proto: "xiaomi_settings"),
        6: .same(proto: "disabled")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
            case 2: try {
                    var v: Stream_Video_ApnSettings?
                    var hadOneofValue = false
                    if let current = self.settings {
                        hadOneofValue = true
                        if case let .apnSettings(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.settings = .apnSettings(v)
                    }
                }()
            case 3: try {
                    var v: Stream_Video_FirebaseSettings?
                    var hadOneofValue = false
                    if let current = self.settings {
                        hadOneofValue = true
                        if case let .firebaseSettings(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.settings = .firebaseSettings(v)
                    }
                }()
            case 4: try {
                    var v: Stream_Video_HuaweiSettings?
                    var hadOneofValue = false
                    if let current = self.settings {
                        hadOneofValue = true
                        if case let .huaweiSettings(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.settings = .huaweiSettings(v)
                    }
                }()
            case 5: try {
                    var v: Stream_Video_XiaomiSettings?
                    var hadOneofValue = false
                    if let current = self.settings {
                        hadOneofValue = true
                        if case let .xiaomiSettings(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.settings = .xiaomiSettings(v)
                    }
                }()
            case 6: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        switch settings {
        case .apnSettings?: try {
                guard case let .apnSettings(v)? = self.settings else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .firebaseSettings?: try {
                guard case let .firebaseSettings(v)? = self.settings else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .huaweiSettings?: try {
                guard case let .huaweiSettings(v)? = self.settings else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .xiaomiSettings?: try {
                guard case let .xiaomiSettings(v)? = self.settings else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        if disabled != false {
            try visitor.visitSingularBoolField(value: disabled, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_PushProvider, rhs: Stream_Video_PushProvider) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.settings != rhs.settings { return false }
        if lhs.disabled != rhs.disabled { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_ApplicationSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ApplicationSettings"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "webhook_url"),
        2: .standard(proto: "push_providers"),
        3: .standard(proto: "sqs_settings")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.webhookURL) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pushProviders) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._sqsSettings) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !webhookURL.isEmpty {
            try visitor.visitSingularStringField(value: webhookURL, fieldNumber: 1)
        }
        if !pushProviders.isEmpty {
            try visitor.visitRepeatedMessageField(value: pushProviders, fieldNumber: 2)
        }
        try { if let v = self._sqsSettings {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_ApplicationSettings, rhs: Stream_Video_ApplicationSettings) -> Bool {
        if lhs.webhookURL != rhs.webhookURL { return false }
        if lhs.pushProviders != rhs.pushProviders { return false }
        if lhs._sqsSettings != rhs._sqsSettings { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
