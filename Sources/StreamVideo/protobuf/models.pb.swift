// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: video_models/models.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Stream_Video_Codec: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case h264Unspecified // = 0
  case vp8 // = 1
  case vp9 // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .h264Unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .h264Unspecified
    case 1: self = .vp8
    case 2: self = .vp9
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .h264Unspecified: return 0
    case .vp8: return 1
    case .vp9: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_Codec: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Codec] = [
    .h264Unspecified,
    .vp8,
    .vp9,
  ]
}

#endif  // swift(>=4.2)

enum Stream_Video_RecordingStorage: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case s3Unspecified // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .s3Unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .s3Unspecified
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .s3Unspecified: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_RecordingStorage: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_RecordingStorage] = [
    .s3Unspecified,
  ]
}

#endif  // swift(>=4.2)

/// Edges are where we deploy video servers
struct Stream_Video_Edge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var latencyURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Edges are where we deploy video servers
struct Stream_Video_EdgeServer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Returns information about the server location
  struct Coordinates {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var lat: Float = 0

    var long: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Stream_Video_Latency {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var measurementsSeconds: [Float] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_File {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var composite: Bool = false

  var userID: String = String()

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_RecordBroadcast {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// if true merge all audio and video, if false split them
  var composite: Bool = false

  var files: [Stream_Video_File] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var teams: [String] = []

  var role: String = String()

  var custom: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _custom ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_custom = newValue}
  }
  /// Returns true if `custom` has been explicitly set.
  var hasCustom: Bool {return self._custom != nil}
  /// Clears the value of `custom`. Subsequent reads from it will return its default value.
  mutating func clearCustom() {self._custom = nil}

  var name: String = String()

  var profileImageURL: String = String()

  /// user creation date as RFC3339 string
  var createdAt: String = String()

  /// user last update date as RFC3339 string
  var updatedAt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

struct Stream_Video_UserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var teams: [String] = []

  var role: String = String()

  var custom: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _custom ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_custom = newValue}
  }
  /// Returns true if `custom` has been explicitly set.
  var hasCustom: Bool {return self._custom != nil}
  /// Clears the value of `custom`. Subsequent reads from it will return its default value.
  mutating func clearCustom() {self._custom = nil}

  var name: String = String()

  var profileImageURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

struct Stream_Video_Device {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var id: String = String()

  var disabled: Bool = false

  var disabledReason: String = String()

  var pushProviderName: String = String()

  var createdAt: String = String()

  var updatedAt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_DeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var id: String = String()

  var disabled: Bool = false

  var disabledReason: String = String()

  var pushProviderName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_RecordingStorageOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var storage: Stream_Video_RecordingStorage = .s3Unspecified

  var accessKey: String = String()

  var secretKey: String = String()

  var bucketName: String = String()

  var region: String = String()

  var path: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_RTMPOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var urls: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Broadcast {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rtmp: Stream_Video_RTMPOptions {
    get {return _rtmp ?? Stream_Video_RTMPOptions()}
    set {_rtmp = newValue}
  }
  /// Returns true if `rtmp` has been explicitly set.
  var hasRtmp: Bool {return self._rtmp != nil}
  /// Clears the value of `rtmp`. Subsequent reads from it will return its default value.
  mutating func clearRtmp() {self._rtmp = nil}

  var hlsURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rtmp: Stream_Video_RTMPOptions? = nil
}

struct Stream_Video_TranscribeOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_CallType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the unique name for the call type
  var name: String = String()

  /// TODO: maybe we need to move this to permissions / own_capabilities
  var security: Stream_Video_Security {
    get {return _security ?? Stream_Video_Security()}
    set {_security = newValue}
  }
  /// Returns true if `security` has been explicitly set.
  var hasSecurity: Bool {return self._security != nil}
  /// Clears the value of `security`. Subsequent reads from it will return its default value.
  mutating func clearSecurity() {self._security = nil}

  /// when recording is true, calls are recorded on S3
  var recording: Bool = false

  /// when enabled, calls get an HLS URL by default
  var hlsBroadcast: Bool = false

  /// enable transcription by default
  var transcribe: Bool = false

  var transcribeOptions: Stream_Video_TranscribeOptions {
    get {return _transcribeOptions ?? Stream_Video_TranscribeOptions()}
    set {_transcribeOptions = newValue}
  }
  /// Returns true if `transcribeOptions` has been explicitly set.
  var hasTranscribeOptions: Bool {return self._transcribeOptions != nil}
  /// Clears the value of `transcribeOptions`. Subsequent reads from it will return its default value.
  mutating func clearTranscribeOptions() {self._transcribeOptions = nil}

  var createdAt: String = String()

  var updatedAt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _security: Stream_Video_Security? = nil
  fileprivate var _transcribeOptions: Stream_Video_TranscribeOptions? = nil
}

struct Stream_Video_Security {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hideProfilePictures: Bool = false

  var shareScreen: Stream_Video_Security.IsAllowed = .yesUnspecified

  var renameUser: Bool = false

  var unmute: Stream_Video_Security.IsAllowed = .yesUnspecified

  var startVideo: Stream_Video_Security.IsAllowed = .yesUnspecified

  var screenShare: Stream_Video_Security.IsAllowed = .yesUnspecified

  var record: Stream_Video_Security.IsAllowed = .yesUnspecified

  var broadcast: Stream_Video_Security.IsAllowed = .yesUnspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// TODO this is actually one of the most complex UI things in zoom :)
  /// controls if regular users are allowed to do the following
  /// yes/no/request
  enum IsAllowed: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case yesUnspecified // = 0
    case no // = 1
    case request // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .yesUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .yesUnspecified
      case 1: self = .no
      case 2: self = .request
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .yesUnspecified: return 0
      case .no: return 1
      case .request: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Stream_Video_Security.IsAllowed: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Security.IsAllowed] = [
    .yesUnspecified,
    .no,
    .request,
  ]
}

#endif  // swift(>=4.2)

/// those who are online in the call
struct Stream_Video_Participant {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var role: String = String()

  var online: Bool = false

  var custom: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _custom ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_custom = newValue}
  }
  /// Returns true if `custom` has been explicitly set.
  var hasCustom: Bool {return self._custom != nil}
  /// Clears the value of `custom`. Subsequent reads from it will return its default value.
  mutating func clearCustom() {self._custom = nil}

  var video: Bool = false

  var audio: Bool = false

  /// call creation date as RFC3339 string
  var createdAt: String = String()

  /// call last update date as RFC3339 string
  var updatedAt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

struct Stream_Video_ParticipantRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var role: String = String()

  /// call custom data
  var custom: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _custom ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_custom = newValue}
  }
  /// Returns true if `custom` has been explicitly set.
  var hasCustom: Bool {return self._custom != nil}
  /// Clears the value of `custom`. Subsequent reads from it will return its default value.
  mutating func clearCustom() {self._custom = nil}

  /// call creation date as RFC3339 string
  var createdAt: String = String()

  /// call last update date as RFC3339 string
  var updatedAt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

struct Stream_Video_CallState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var participants: [Stream_Video_Participant] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Call {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the call type
  var type: String = String()

  /// the call id
  var id: String = String()

  /// the id of the user that created this call
  var createdByUserID: String = String()

  var custom: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _custom ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_custom = newValue}
  }
  /// Returns true if `custom` has been explicitly set.
  var hasCustom: Bool {return self._custom != nil}
  /// Clears the value of `custom`. Subsequent reads from it will return its default value.
  mutating func clearCustom() {self._custom = nil}

  /// call creation date as RFC3339 string
  var createdAt: String = String()

  /// call last update date as RFC3339 string
  var updatedAt: String = String()

  /// when recording is true, calls are recorded on S3
  var recording: Bool = false

  /// broadcast settings for this call
  var broadcast: Stream_Video_Broadcast {
    get {return _broadcast ?? Stream_Video_Broadcast()}
    set {_broadcast = newValue}
  }
  /// Returns true if `broadcast` has been explicitly set.
  var hasBroadcast: Bool {return self._broadcast != nil}
  /// Clears the value of `broadcast`. Subsequent reads from it will return its default value.
  mutating func clearBroadcast() {self._broadcast = nil}

  /// enable transcription by default
  var transcribe: Bool = false

  var transcribeOptions: Stream_Video_TranscribeOptions {
    get {return _transcribeOptions ?? Stream_Video_TranscribeOptions()}
    set {_transcribeOptions = newValue}
  }
  /// Returns true if `transcribeOptions` has been explicitly set.
  var hasTranscribeOptions: Bool {return self._transcribeOptions != nil}
  /// Clears the value of `transcribeOptions`. Subsequent reads from it will return its default value.
  mutating func clearTranscribeOptions() {self._transcribeOptions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _broadcast: Stream_Video_Broadcast? = nil
  fileprivate var _transcribeOptions: Stream_Video_TranscribeOptions? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stream_Video_Codec: @unchecked Sendable {}
extension Stream_Video_RecordingStorage: @unchecked Sendable {}
extension Stream_Video_Edge: @unchecked Sendable {}
extension Stream_Video_EdgeServer: @unchecked Sendable {}
extension Stream_Video_EdgeServer.Coordinates: @unchecked Sendable {}
extension Stream_Video_Latency: @unchecked Sendable {}
extension Stream_Video_File: @unchecked Sendable {}
extension Stream_Video_RecordBroadcast: @unchecked Sendable {}
extension Stream_Video_User: @unchecked Sendable {}
extension Stream_Video_UserRequest: @unchecked Sendable {}
extension Stream_Video_Device: @unchecked Sendable {}
extension Stream_Video_DeviceRequest: @unchecked Sendable {}
extension Stream_Video_RecordingStorageOptions: @unchecked Sendable {}
extension Stream_Video_RTMPOptions: @unchecked Sendable {}
extension Stream_Video_Broadcast: @unchecked Sendable {}
extension Stream_Video_TranscribeOptions: @unchecked Sendable {}
extension Stream_Video_CallType: @unchecked Sendable {}
extension Stream_Video_Security: @unchecked Sendable {}
extension Stream_Video_Security.IsAllowed: @unchecked Sendable {}
extension Stream_Video_Participant: @unchecked Sendable {}
extension Stream_Video_ParticipantRequest: @unchecked Sendable {}
extension Stream_Video_CallState: @unchecked Sendable {}
extension Stream_Video_Call: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stream.video"

extension Stream_Video_Codec: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CODEC_H264_UNSPECIFIED"),
    1: .same(proto: "CODEC_VP8"),
    2: .same(proto: "CODEC_VP9"),
  ]
}

extension Stream_Video_RecordingStorage: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RECORDING_STORAGE_S3_UNSPECIFIED"),
  ]
}

extension Stream_Video_Edge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Edge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "latency_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.latencyURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.latencyURL.isEmpty {
      try visitor.visitSingularStringField(value: self.latencyURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Edge, rhs: Stream_Video_Edge) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.latencyURL != rhs.latencyURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_EdgeServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EdgeServer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_EdgeServer, rhs: Stream_Video_EdgeServer) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_EdgeServer.Coordinates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Stream_Video_EdgeServer.protoMessageName + ".Coordinates"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lat"),
    2: .same(proto: "long"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.lat) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.long) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lat != 0 {
      try visitor.visitSingularFloatField(value: self.lat, fieldNumber: 1)
    }
    if self.long != 0 {
      try visitor.visitSingularFloatField(value: self.long, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_EdgeServer.Coordinates, rhs: Stream_Video_EdgeServer.Coordinates) -> Bool {
    if lhs.lat != rhs.lat {return false}
    if lhs.long != rhs.long {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Latency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Latency"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "measurements_seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.measurementsSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.measurementsSeconds.isEmpty {
      try visitor.visitPackedFloatField(value: self.measurementsSeconds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Latency, rhs: Stream_Video_Latency) -> Bool {
    if lhs.measurementsSeconds != rhs.measurementsSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".File"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "composite"),
    3: .standard(proto: "user_id"),
    4: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.composite) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.composite != false {
      try visitor.visitSingularBoolField(value: self.composite, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_File, rhs: Stream_Video_File) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.composite != rhs.composite {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_RecordBroadcast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordBroadcast"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "composite"),
    2: .same(proto: "files"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.composite) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.files) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.composite != false {
      try visitor.visitSingularBoolField(value: self.composite, fieldNumber: 1)
    }
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_RecordBroadcast, rhs: Stream_Video_RecordBroadcast) -> Bool {
    if lhs.composite != rhs.composite {return false}
    if lhs.files != rhs.files {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "teams"),
    3: .same(proto: "role"),
    4: .same(proto: "custom"),
    5: .same(proto: "name"),
    6: .standard(proto: "profile_image_url"),
    7: .standard(proto: "created_at"),
    8: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.teams) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.profileImageURL) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.teams.isEmpty {
      try visitor.visitRepeatedStringField(value: self.teams, fieldNumber: 2)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 3)
    }
    try { if let v = self._custom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if !self.profileImageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.profileImageURL, fieldNumber: 6)
    }
    if !self.createdAt.isEmpty {
      try visitor.visitSingularStringField(value: self.createdAt, fieldNumber: 7)
    }
    if !self.updatedAt.isEmpty {
      try visitor.visitSingularStringField(value: self.updatedAt, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_User, rhs: Stream_Video_User) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.teams != rhs.teams {return false}
    if lhs.role != rhs.role {return false}
    if lhs._custom != rhs._custom {return false}
    if lhs.name != rhs.name {return false}
    if lhs.profileImageURL != rhs.profileImageURL {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.updatedAt != rhs.updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_UserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "teams"),
    3: .same(proto: "role"),
    4: .same(proto: "custom"),
    5: .same(proto: "name"),
    6: .standard(proto: "profile_image_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.teams) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.profileImageURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.teams.isEmpty {
      try visitor.visitRepeatedStringField(value: self.teams, fieldNumber: 2)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 3)
    }
    try { if let v = self._custom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if !self.profileImageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.profileImageURL, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_UserRequest, rhs: Stream_Video_UserRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.teams != rhs.teams {return false}
    if lhs.role != rhs.role {return false}
    if lhs._custom != rhs._custom {return false}
    if lhs.name != rhs.name {return false}
    if lhs.profileImageURL != rhs.profileImageURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Device"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "id"),
    3: .same(proto: "disabled"),
    4: .standard(proto: "disabled_reason"),
    5: .standard(proto: "push_provider_name"),
    6: .standard(proto: "created_at"),
    7: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.disabledReason) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.pushProviderName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 3)
    }
    if !self.disabledReason.isEmpty {
      try visitor.visitSingularStringField(value: self.disabledReason, fieldNumber: 4)
    }
    if !self.pushProviderName.isEmpty {
      try visitor.visitSingularStringField(value: self.pushProviderName, fieldNumber: 5)
    }
    if !self.createdAt.isEmpty {
      try visitor.visitSingularStringField(value: self.createdAt, fieldNumber: 6)
    }
    if !self.updatedAt.isEmpty {
      try visitor.visitSingularStringField(value: self.updatedAt, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Device, rhs: Stream_Video_Device) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.disabled != rhs.disabled {return false}
    if lhs.disabledReason != rhs.disabledReason {return false}
    if lhs.pushProviderName != rhs.pushProviderName {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.updatedAt != rhs.updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_DeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "id"),
    3: .same(proto: "disabled"),
    4: .standard(proto: "disabled_reason"),
    5: .standard(proto: "push_provider_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.disabledReason) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.pushProviderName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 3)
    }
    if !self.disabledReason.isEmpty {
      try visitor.visitSingularStringField(value: self.disabledReason, fieldNumber: 4)
    }
    if !self.pushProviderName.isEmpty {
      try visitor.visitSingularStringField(value: self.pushProviderName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_DeviceRequest, rhs: Stream_Video_DeviceRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.disabled != rhs.disabled {return false}
    if lhs.disabledReason != rhs.disabledReason {return false}
    if lhs.pushProviderName != rhs.pushProviderName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_RecordingStorageOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordingStorageOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "storage"),
    3: .standard(proto: "access_key"),
    4: .standard(proto: "secret_key"),
    5: .standard(proto: "bucket_name"),
    6: .same(proto: "region"),
    7: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularEnumField(value: &self.storage) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.accessKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.secretKey) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.bucketName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storage != .s3Unspecified {
      try visitor.visitSingularEnumField(value: self.storage, fieldNumber: 2)
    }
    if !self.accessKey.isEmpty {
      try visitor.visitSingularStringField(value: self.accessKey, fieldNumber: 3)
    }
    if !self.secretKey.isEmpty {
      try visitor.visitSingularStringField(value: self.secretKey, fieldNumber: 4)
    }
    if !self.bucketName.isEmpty {
      try visitor.visitSingularStringField(value: self.bucketName, fieldNumber: 5)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 6)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_RecordingStorageOptions, rhs: Stream_Video_RecordingStorageOptions) -> Bool {
    if lhs.storage != rhs.storage {return false}
    if lhs.accessKey != rhs.accessKey {return false}
    if lhs.secretKey != rhs.secretKey {return false}
    if lhs.bucketName != rhs.bucketName {return false}
    if lhs.region != rhs.region {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_RTMPOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RTMPOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "urls"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.urls) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.urls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.urls, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_RTMPOptions, rhs: Stream_Video_RTMPOptions) -> Bool {
    if lhs.urls != rhs.urls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Broadcast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Broadcast"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rtmp"),
    2: .standard(proto: "hls_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rtmp) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hlsURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rtmp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.hlsURL.isEmpty {
      try visitor.visitSingularStringField(value: self.hlsURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Broadcast, rhs: Stream_Video_Broadcast) -> Bool {
    if lhs._rtmp != rhs._rtmp {return false}
    if lhs.hlsURL != rhs.hlsURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_TranscribeOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TranscribeOptions"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_TranscribeOptions, rhs: Stream_Video_TranscribeOptions) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_CallType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "security"),
    4: .same(proto: "recording"),
    5: .standard(proto: "hls_broadcast"),
    6: .same(proto: "transcribe"),
    7: .standard(proto: "transcribe_options"),
    8: .standard(proto: "created_at"),
    9: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._security) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.recording) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.hlsBroadcast) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.transcribe) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._transcribeOptions) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._security {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.recording != false {
      try visitor.visitSingularBoolField(value: self.recording, fieldNumber: 4)
    }
    if self.hlsBroadcast != false {
      try visitor.visitSingularBoolField(value: self.hlsBroadcast, fieldNumber: 5)
    }
    if self.transcribe != false {
      try visitor.visitSingularBoolField(value: self.transcribe, fieldNumber: 6)
    }
    try { if let v = self._transcribeOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.createdAt.isEmpty {
      try visitor.visitSingularStringField(value: self.createdAt, fieldNumber: 8)
    }
    if !self.updatedAt.isEmpty {
      try visitor.visitSingularStringField(value: self.updatedAt, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_CallType, rhs: Stream_Video_CallType) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._security != rhs._security {return false}
    if lhs.recording != rhs.recording {return false}
    if lhs.hlsBroadcast != rhs.hlsBroadcast {return false}
    if lhs.transcribe != rhs.transcribe {return false}
    if lhs._transcribeOptions != rhs._transcribeOptions {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.updatedAt != rhs.updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Security: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Security"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hide_profile_pictures"),
    2: .standard(proto: "share_screen"),
    3: .standard(proto: "rename_user"),
    4: .same(proto: "unmute"),
    5: .standard(proto: "start_video"),
    6: .standard(proto: "screen_share"),
    7: .same(proto: "record"),
    8: .same(proto: "broadcast"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.hideProfilePictures) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.shareScreen) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.renameUser) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.unmute) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.startVideo) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.screenShare) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.record) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.broadcast) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hideProfilePictures != false {
      try visitor.visitSingularBoolField(value: self.hideProfilePictures, fieldNumber: 1)
    }
    if self.shareScreen != .yesUnspecified {
      try visitor.visitSingularEnumField(value: self.shareScreen, fieldNumber: 2)
    }
    if self.renameUser != false {
      try visitor.visitSingularBoolField(value: self.renameUser, fieldNumber: 3)
    }
    if self.unmute != .yesUnspecified {
      try visitor.visitSingularEnumField(value: self.unmute, fieldNumber: 4)
    }
    if self.startVideo != .yesUnspecified {
      try visitor.visitSingularEnumField(value: self.startVideo, fieldNumber: 5)
    }
    if self.screenShare != .yesUnspecified {
      try visitor.visitSingularEnumField(value: self.screenShare, fieldNumber: 6)
    }
    if self.record != .yesUnspecified {
      try visitor.visitSingularEnumField(value: self.record, fieldNumber: 7)
    }
    if self.broadcast != .yesUnspecified {
      try visitor.visitSingularEnumField(value: self.broadcast, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Security, rhs: Stream_Video_Security) -> Bool {
    if lhs.hideProfilePictures != rhs.hideProfilePictures {return false}
    if lhs.shareScreen != rhs.shareScreen {return false}
    if lhs.renameUser != rhs.renameUser {return false}
    if lhs.unmute != rhs.unmute {return false}
    if lhs.startVideo != rhs.startVideo {return false}
    if lhs.screenShare != rhs.screenShare {return false}
    if lhs.record != rhs.record {return false}
    if lhs.broadcast != rhs.broadcast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Security.IsAllowed: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IS_ALLOWED_YES_UNSPECIFIED"),
    1: .same(proto: "IS_ALLOWED_NO"),
    2: .same(proto: "IS_ALLOWED_REQUEST"),
  ]
}

extension Stream_Video_Participant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Participant"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "role"),
    3: .same(proto: "online"),
    4: .same(proto: "custom"),
    5: .same(proto: "video"),
    6: .same(proto: "audio"),
    7: .standard(proto: "created_at"),
    8: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.online) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.video) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.audio) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 2)
    }
    if self.online != false {
      try visitor.visitSingularBoolField(value: self.online, fieldNumber: 3)
    }
    try { if let v = self._custom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.video != false {
      try visitor.visitSingularBoolField(value: self.video, fieldNumber: 5)
    }
    if self.audio != false {
      try visitor.visitSingularBoolField(value: self.audio, fieldNumber: 6)
    }
    if !self.createdAt.isEmpty {
      try visitor.visitSingularStringField(value: self.createdAt, fieldNumber: 7)
    }
    if !self.updatedAt.isEmpty {
      try visitor.visitSingularStringField(value: self.updatedAt, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Participant, rhs: Stream_Video_Participant) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.role != rhs.role {return false}
    if lhs.online != rhs.online {return false}
    if lhs._custom != rhs._custom {return false}
    if lhs.video != rhs.video {return false}
    if lhs.audio != rhs.audio {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.updatedAt != rhs.updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_ParticipantRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipantRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "role"),
    3: .same(proto: "custom"),
    4: .standard(proto: "created_at"),
    5: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 2)
    }
    try { if let v = self._custom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.createdAt.isEmpty {
      try visitor.visitSingularStringField(value: self.createdAt, fieldNumber: 4)
    }
    if !self.updatedAt.isEmpty {
      try visitor.visitSingularStringField(value: self.updatedAt, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_ParticipantRequest, rhs: Stream_Video_ParticipantRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.role != rhs.role {return false}
    if lhs._custom != rhs._custom {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.updatedAt != rhs.updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_CallState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "participants"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.participants) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.participants.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.participants, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_CallState, rhs: Stream_Video_CallState) -> Bool {
    if lhs.participants != rhs.participants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Call: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Call"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .standard(proto: "created_by_user_id"),
    4: .same(proto: "custom"),
    5: .standard(proto: "created_at"),
    6: .standard(proto: "updated_at"),
    7: .same(proto: "recording"),
    8: .same(proto: "broadcast"),
    9: .same(proto: "transcribe"),
    10: .standard(proto: "transcribe_options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.createdByUserID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.recording) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._broadcast) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.transcribe) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._transcribeOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.createdByUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.createdByUserID, fieldNumber: 3)
    }
    try { if let v = self._custom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.createdAt.isEmpty {
      try visitor.visitSingularStringField(value: self.createdAt, fieldNumber: 5)
    }
    if !self.updatedAt.isEmpty {
      try visitor.visitSingularStringField(value: self.updatedAt, fieldNumber: 6)
    }
    if self.recording != false {
      try visitor.visitSingularBoolField(value: self.recording, fieldNumber: 7)
    }
    try { if let v = self._broadcast {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.transcribe != false {
      try visitor.visitSingularBoolField(value: self.transcribe, fieldNumber: 9)
    }
    try { if let v = self._transcribeOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Call, rhs: Stream_Video_Call) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.createdByUserID != rhs.createdByUserID {return false}
    if lhs._custom != rhs._custom {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.updatedAt != rhs.updatedAt {return false}
    if lhs.recording != rhs.recording {return false}
    if lhs._broadcast != rhs._broadcast {return false}
    if lhs.transcribe != rhs.transcribe {return false}
    if lhs._transcribeOptions != rhs._transcribeOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
