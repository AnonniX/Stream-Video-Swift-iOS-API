// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: video_models/models.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Stream_Video_Codec: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case h264Unspecified // = 0
  case vp8 // = 1
  case vp9 // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .h264Unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .h264Unspecified
    case 1: self = .vp8
    case 2: self = .vp9
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .h264Unspecified: return 0
    case .vp8: return 1
    case .vp9: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_Codec: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Codec] = [
    .h264Unspecified,
    .vp8,
    .vp9,
  ]
}

#endif  // swift(>=4.2)

enum Stream_Video_RecordingStorage: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case s3Unspecified // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .s3Unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .s3Unspecified
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .s3Unspecified: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_RecordingStorage: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_RecordingStorage] = [
    .s3Unspecified,
  ]
}

#endif  // swift(>=4.2)

/// Edges are where we deploy video servers
struct Stream_Video_Edge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var latencyURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Edges are where we deploy video servers
struct Stream_Video_EdgeServer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Latency {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var measurements: [Float] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 3 different type of broadcast
struct Stream_Video_Broadcast {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var details: Stream_Video_Broadcast.OneOf_Details? = nil

  var rtmp: Stream_Video_RTMPBroadcast {
    get {
      if case .rtmp(let v)? = details {return v}
      return Stream_Video_RTMPBroadcast()
    }
    set {details = .rtmp(newValue)}
  }

  var hls: Stream_Video_HLSBroadcast {
    get {
      if case .hls(let v)? = details {return v}
      return Stream_Video_HLSBroadcast()
    }
    set {details = .hls(newValue)}
  }

  var record: Stream_Video_RecordBroadcast {
    get {
      if case .record(let v)? = details {return v}
      return Stream_Video_RecordBroadcast()
    }
    set {details = .record(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Details: Equatable {
    case rtmp(Stream_Video_RTMPBroadcast)
    case hls(Stream_Video_HLSBroadcast)
    case record(Stream_Video_RecordBroadcast)

  #if !swift(>=4.1)
    static func ==(lhs: Stream_Video_Broadcast.OneOf_Details, rhs: Stream_Video_Broadcast.OneOf_Details) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.rtmp, .rtmp): return {
        guard case .rtmp(let l) = lhs, case .rtmp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hls, .hls): return {
        guard case .hls(let l) = lhs, case .hls(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.record, .record): return {
        guard case .record(let l) = lhs, case .record(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Stream_Video_RTMPBroadcast {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var callID: String = String()

  var rtmpurls: [String] = []

  var width: Int32 = 0

  var height: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_HLSBroadcast {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_File {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var composite: Bool = false

  var userID: String = String()

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_RecordBroadcast {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// if true merge all audio and video, if false split them
  var composite: Bool = false

  var files: [Stream_Video_File] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  /// TODO: zoom allows you to invite any of your colleagues in their invite screen
  var teams: [String] = []

  var type: String = String()

  var createdAt: String = String()

  var updatedAt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Device {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var id: String = String()

  var disabled: Bool = false

  var disabledReason: String = String()

  var pushProviderName: String = String()

  var createdAt: String = String()

  var updatedAt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_RecordingStorageOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var storage: Stream_Video_RecordingStorage = .s3Unspecified

  var accessKey: String = String()

  var secretKey: String = String()

  var bucketName: String = String()

  var region: String = String()

  var path: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_BroadcastOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rtmpURL: String = String()

  var hlsURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_TranscribeOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_CallType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var security: Stream_Video_Security {
    get {return _security ?? Stream_Video_Security()}
    set {_security = newValue}
  }
  /// Returns true if `security` has been explicitly set.
  var hasSecurity: Bool {return self._security != nil}
  /// Clears the value of `security`. Subsequent reads from it will return its default value.
  mutating func clearSecurity() {self._security = nil}

  /// enable broadcasting by default when creating a call of this type
  var broadcast: Bool = false

  var broadcastOptions: [Stream_Video_BroadcastOptions] = []

  /// enable transcription by default
  var transcribe: Bool = false

  var transcribeOptions: Stream_Video_TranscribeOptions {
    get {return _transcribeOptions ?? Stream_Video_TranscribeOptions()}
    set {_transcribeOptions = newValue}
  }
  /// Returns true if `transcribeOptions` has been explicitly set.
  var hasTranscribeOptions: Bool {return self._transcribeOptions != nil}
  /// Clears the value of `transcribeOptions`. Subsequent reads from it will return its default value.
  mutating func clearTranscribeOptions() {self._transcribeOptions = nil}

  var createdAt: String = String()

  var updatedAt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _security: Stream_Video_Security? = nil
  fileprivate var _transcribeOptions: Stream_Video_TranscribeOptions? = nil
}

struct Stream_Video_Security {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hideProfilePictures: Bool = false

  var shareScreen: Stream_Video_Security.IsAllowed = .yesUnspecified

  var renameUser: Bool = false

  var unmute: Stream_Video_Security.IsAllowed = .yesUnspecified

  var startVideo: Stream_Video_Security.IsAllowed = .yesUnspecified

  var screenShare: Stream_Video_Security.IsAllowed = .yesUnspecified

  var record: Stream_Video_Security.IsAllowed = .yesUnspecified

  var broadcast: Stream_Video_Security.IsAllowed = .yesUnspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// TODO this is actually one of the most complex UI things in zoom :)
  /// controls if regular users are allowed to do the following
  /// yes/no/request
  enum IsAllowed: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case yesUnspecified // = 0
    case no // = 1
    case request // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .yesUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .yesUnspecified
      case 1: self = .no
      case 2: self = .request
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .yesUnspecified: return 0
      case .no: return 1
      case .request: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Stream_Video_Security.IsAllowed: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Security.IsAllowed] = [
    .yesUnspecified,
    .no,
    .request,
  ]
}

#endif  // swift(>=4.2)

/// those who are online in the call
struct Stream_Video_Participant {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var role: String = String()

  var online: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_CallState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var participants: [Stream_Video_Participant] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Call {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the call type
  var type: String = String()

  /// the call id
  var id: String = String()

  /// the id of the user that created this call
  var createdByUserID: String = String()

  /// call creation date as RFC3339 string
  var createdAt: String = String()

  /// call last update date as RFC3339 string
  var updatedAt: String = String()

  /// enable broadcasting by default when creating a call of this type
  var broadcast: Bool = false

  var broadcastOptions: [Stream_Video_BroadcastOptions] = []

  /// enable transcription by default
  var transcribe: Bool = false

  var transcribeOptions: Stream_Video_TranscribeOptions {
    get {return _transcribeOptions ?? Stream_Video_TranscribeOptions()}
    set {_transcribeOptions = newValue}
  }
  /// Returns true if `transcribeOptions` has been explicitly set.
  var hasTranscribeOptions: Bool {return self._transcribeOptions != nil}
  /// Clears the value of `transcribeOptions`. Subsequent reads from it will return its default value.
  mutating func clearTranscribeOptions() {self._transcribeOptions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transcribeOptions: Stream_Video_TranscribeOptions? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stream_Video_Codec: @unchecked Sendable {}
extension Stream_Video_RecordingStorage: @unchecked Sendable {}
extension Stream_Video_Edge: @unchecked Sendable {}
extension Stream_Video_EdgeServer: @unchecked Sendable {}
extension Stream_Video_Latency: @unchecked Sendable {}
extension Stream_Video_Broadcast: @unchecked Sendable {}
extension Stream_Video_Broadcast.OneOf_Details: @unchecked Sendable {}
extension Stream_Video_RTMPBroadcast: @unchecked Sendable {}
extension Stream_Video_HLSBroadcast: @unchecked Sendable {}
extension Stream_Video_File: @unchecked Sendable {}
extension Stream_Video_RecordBroadcast: @unchecked Sendable {}
extension Stream_Video_User: @unchecked Sendable {}
extension Stream_Video_Device: @unchecked Sendable {}
extension Stream_Video_RecordingStorageOptions: @unchecked Sendable {}
extension Stream_Video_BroadcastOptions: @unchecked Sendable {}
extension Stream_Video_TranscribeOptions: @unchecked Sendable {}
extension Stream_Video_CallType: @unchecked Sendable {}
extension Stream_Video_Security: @unchecked Sendable {}
extension Stream_Video_Security.IsAllowed: @unchecked Sendable {}
extension Stream_Video_Participant: @unchecked Sendable {}
extension Stream_Video_CallState: @unchecked Sendable {}
extension Stream_Video_Call: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stream.video"

extension Stream_Video_Codec: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CODEC_H264_UNSPECIFIED"),
    1: .same(proto: "CODEC_VP8"),
    2: .same(proto: "CODEC_VP9"),
  ]
}

extension Stream_Video_RecordingStorage: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RECORDING_STORAGE_S3_UNSPECIFIED"),
  ]
}

extension Stream_Video_Edge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Edge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "latency_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.latencyURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.latencyURL.isEmpty {
      try visitor.visitSingularStringField(value: self.latencyURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Edge, rhs: Stream_Video_Edge) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.latencyURL != rhs.latencyURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_EdgeServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EdgeServer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_EdgeServer, rhs: Stream_Video_EdgeServer) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Latency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Latency"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "measurements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.measurements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.measurements.isEmpty {
      try visitor.visitPackedFloatField(value: self.measurements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Latency, rhs: Stream_Video_Latency) -> Bool {
    if lhs.measurements != rhs.measurements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Broadcast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Broadcast"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "rtmp"),
    3: .same(proto: "hls"),
    4: .same(proto: "record"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try {
        var v: Stream_Video_RTMPBroadcast?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .rtmp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .rtmp(v)
        }
      }()
      case 3: try {
        var v: Stream_Video_HLSBroadcast?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .hls(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .hls(v)
        }
      }()
      case 4: try {
        var v: Stream_Video_RecordBroadcast?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .record(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .record(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    switch self.details {
    case .rtmp?: try {
      guard case .rtmp(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .hls?: try {
      guard case .hls(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .record?: try {
      guard case .record(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Broadcast, rhs: Stream_Video_Broadcast) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_RTMPBroadcast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RTMPBroadcast"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .same(proto: "rtmpurls"),
    3: .same(proto: "width"),
    4: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.rtmpurls) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if !self.rtmpurls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.rtmpurls, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_RTMPBroadcast, rhs: Stream_Video_RTMPBroadcast) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.rtmpurls != rhs.rtmpurls {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_HLSBroadcast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HLSBroadcast"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_HLSBroadcast, rhs: Stream_Video_HLSBroadcast) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".File"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "composite"),
    3: .standard(proto: "user_id"),
    4: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.composite) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.composite != false {
      try visitor.visitSingularBoolField(value: self.composite, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_File, rhs: Stream_Video_File) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.composite != rhs.composite {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_RecordBroadcast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordBroadcast"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "composite"),
    2: .same(proto: "files"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.composite) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.files) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.composite != false {
      try visitor.visitSingularBoolField(value: self.composite, fieldNumber: 1)
    }
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_RecordBroadcast, rhs: Stream_Video_RecordBroadcast) -> Bool {
    if lhs.composite != rhs.composite {return false}
    if lhs.files != rhs.files {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "teams"),
    3: .same(proto: "type"),
    7: .standard(proto: "created_at"),
    8: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.teams) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.teams.isEmpty {
      try visitor.visitRepeatedStringField(value: self.teams, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    if !self.createdAt.isEmpty {
      try visitor.visitSingularStringField(value: self.createdAt, fieldNumber: 7)
    }
    if !self.updatedAt.isEmpty {
      try visitor.visitSingularStringField(value: self.updatedAt, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_User, rhs: Stream_Video_User) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.teams != rhs.teams {return false}
    if lhs.type != rhs.type {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.updatedAt != rhs.updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Device"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "id"),
    3: .same(proto: "disabled"),
    4: .standard(proto: "disabled_reason"),
    5: .standard(proto: "push_provider_name"),
    6: .standard(proto: "created_at"),
    7: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.disabledReason) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.pushProviderName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 3)
    }
    if !self.disabledReason.isEmpty {
      try visitor.visitSingularStringField(value: self.disabledReason, fieldNumber: 4)
    }
    if !self.pushProviderName.isEmpty {
      try visitor.visitSingularStringField(value: self.pushProviderName, fieldNumber: 5)
    }
    if !self.createdAt.isEmpty {
      try visitor.visitSingularStringField(value: self.createdAt, fieldNumber: 6)
    }
    if !self.updatedAt.isEmpty {
      try visitor.visitSingularStringField(value: self.updatedAt, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Device, rhs: Stream_Video_Device) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.disabled != rhs.disabled {return false}
    if lhs.disabledReason != rhs.disabledReason {return false}
    if lhs.pushProviderName != rhs.pushProviderName {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.updatedAt != rhs.updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_RecordingStorageOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordingStorageOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "storage"),
    3: .standard(proto: "access_key"),
    4: .standard(proto: "secret_key"),
    5: .standard(proto: "bucket_name"),
    6: .same(proto: "region"),
    7: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularEnumField(value: &self.storage) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.accessKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.secretKey) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.bucketName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storage != .s3Unspecified {
      try visitor.visitSingularEnumField(value: self.storage, fieldNumber: 2)
    }
    if !self.accessKey.isEmpty {
      try visitor.visitSingularStringField(value: self.accessKey, fieldNumber: 3)
    }
    if !self.secretKey.isEmpty {
      try visitor.visitSingularStringField(value: self.secretKey, fieldNumber: 4)
    }
    if !self.bucketName.isEmpty {
      try visitor.visitSingularStringField(value: self.bucketName, fieldNumber: 5)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 6)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_RecordingStorageOptions, rhs: Stream_Video_RecordingStorageOptions) -> Bool {
    if lhs.storage != rhs.storage {return false}
    if lhs.accessKey != rhs.accessKey {return false}
    if lhs.secretKey != rhs.secretKey {return false}
    if lhs.bucketName != rhs.bucketName {return false}
    if lhs.region != rhs.region {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_BroadcastOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BroadcastOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rtmp_url"),
    2: .standard(proto: "hls_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rtmpURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hlsURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rtmpURL.isEmpty {
      try visitor.visitSingularStringField(value: self.rtmpURL, fieldNumber: 1)
    }
    if !self.hlsURL.isEmpty {
      try visitor.visitSingularStringField(value: self.hlsURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_BroadcastOptions, rhs: Stream_Video_BroadcastOptions) -> Bool {
    if lhs.rtmpURL != rhs.rtmpURL {return false}
    if lhs.hlsURL != rhs.hlsURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_TranscribeOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TranscribeOptions"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_TranscribeOptions, rhs: Stream_Video_TranscribeOptions) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_CallType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "security"),
    3: .same(proto: "broadcast"),
    4: .standard(proto: "broadcast_options"),
    5: .same(proto: "transcribe"),
    6: .standard(proto: "transcribe_options"),
    7: .standard(proto: "created_at"),
    8: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._security) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.broadcast) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.broadcastOptions) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.transcribe) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._transcribeOptions) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._security {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.broadcast != false {
      try visitor.visitSingularBoolField(value: self.broadcast, fieldNumber: 3)
    }
    if !self.broadcastOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.broadcastOptions, fieldNumber: 4)
    }
    if self.transcribe != false {
      try visitor.visitSingularBoolField(value: self.transcribe, fieldNumber: 5)
    }
    try { if let v = self._transcribeOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.createdAt.isEmpty {
      try visitor.visitSingularStringField(value: self.createdAt, fieldNumber: 7)
    }
    if !self.updatedAt.isEmpty {
      try visitor.visitSingularStringField(value: self.updatedAt, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_CallType, rhs: Stream_Video_CallType) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._security != rhs._security {return false}
    if lhs.broadcast != rhs.broadcast {return false}
    if lhs.broadcastOptions != rhs.broadcastOptions {return false}
    if lhs.transcribe != rhs.transcribe {return false}
    if lhs._transcribeOptions != rhs._transcribeOptions {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.updatedAt != rhs.updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Security: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Security"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hide_profile_pictures"),
    2: .standard(proto: "share_screen"),
    3: .standard(proto: "rename_user"),
    4: .same(proto: "unmute"),
    5: .standard(proto: "start_video"),
    6: .standard(proto: "screen_share"),
    7: .same(proto: "record"),
    8: .same(proto: "broadcast"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.hideProfilePictures) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.shareScreen) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.renameUser) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.unmute) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.startVideo) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.screenShare) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.record) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.broadcast) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hideProfilePictures != false {
      try visitor.visitSingularBoolField(value: self.hideProfilePictures, fieldNumber: 1)
    }
    if self.shareScreen != .yesUnspecified {
      try visitor.visitSingularEnumField(value: self.shareScreen, fieldNumber: 2)
    }
    if self.renameUser != false {
      try visitor.visitSingularBoolField(value: self.renameUser, fieldNumber: 3)
    }
    if self.unmute != .yesUnspecified {
      try visitor.visitSingularEnumField(value: self.unmute, fieldNumber: 4)
    }
    if self.startVideo != .yesUnspecified {
      try visitor.visitSingularEnumField(value: self.startVideo, fieldNumber: 5)
    }
    if self.screenShare != .yesUnspecified {
      try visitor.visitSingularEnumField(value: self.screenShare, fieldNumber: 6)
    }
    if self.record != .yesUnspecified {
      try visitor.visitSingularEnumField(value: self.record, fieldNumber: 7)
    }
    if self.broadcast != .yesUnspecified {
      try visitor.visitSingularEnumField(value: self.broadcast, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Security, rhs: Stream_Video_Security) -> Bool {
    if lhs.hideProfilePictures != rhs.hideProfilePictures {return false}
    if lhs.shareScreen != rhs.shareScreen {return false}
    if lhs.renameUser != rhs.renameUser {return false}
    if lhs.unmute != rhs.unmute {return false}
    if lhs.startVideo != rhs.startVideo {return false}
    if lhs.screenShare != rhs.screenShare {return false}
    if lhs.record != rhs.record {return false}
    if lhs.broadcast != rhs.broadcast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Security.IsAllowed: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IS_ALLOWED_YES_UNSPECIFIED"),
    1: .same(proto: "IS_ALLOWED_NO"),
    2: .same(proto: "IS_ALLOWED_REQUEST"),
  ]
}

extension Stream_Video_Participant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Participant"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "role"),
    3: .same(proto: "online"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.online) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 2)
    }
    if self.online != false {
      try visitor.visitSingularBoolField(value: self.online, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Participant, rhs: Stream_Video_Participant) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.role != rhs.role {return false}
    if lhs.online != rhs.online {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_CallState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "participants"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.participants) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.participants.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.participants, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_CallState, rhs: Stream_Video_CallState) -> Bool {
    if lhs.participants != rhs.participants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Call: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Call"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .standard(proto: "created_by_user_id"),
    4: .standard(proto: "created_at"),
    5: .standard(proto: "updated_at"),
    6: .same(proto: "broadcast"),
    7: .standard(proto: "broadcast_options"),
    8: .same(proto: "transcribe"),
    9: .standard(proto: "transcribe_options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.createdByUserID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.createdAt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.broadcast) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.broadcastOptions) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.transcribe) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._transcribeOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.createdByUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.createdByUserID, fieldNumber: 3)
    }
    if !self.createdAt.isEmpty {
      try visitor.visitSingularStringField(value: self.createdAt, fieldNumber: 4)
    }
    if !self.updatedAt.isEmpty {
      try visitor.visitSingularStringField(value: self.updatedAt, fieldNumber: 5)
    }
    if self.broadcast != false {
      try visitor.visitSingularBoolField(value: self.broadcast, fieldNumber: 6)
    }
    if !self.broadcastOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.broadcastOptions, fieldNumber: 7)
    }
    if self.transcribe != false {
      try visitor.visitSingularBoolField(value: self.transcribe, fieldNumber: 8)
    }
    try { if let v = self._transcribeOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Call, rhs: Stream_Video_Call) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.createdByUserID != rhs.createdByUserID {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.updatedAt != rhs.updatedAt {return false}
    if lhs.broadcast != rhs.broadcast {return false}
    if lhs.broadcastOptions != rhs.broadcastOptions {return false}
    if lhs.transcribe != rhs.transcribe {return false}
    if lhs._transcribeOptions != rhs._transcribeOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
