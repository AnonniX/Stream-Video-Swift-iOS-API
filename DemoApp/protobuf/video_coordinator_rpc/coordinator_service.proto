syntax = "proto3";

package stream.video;

option go_package = "github.com/GetStream/video/protobuf/video_coordinator_rpc";

import "video_models/models.proto";
import "validate/validate.proto";

// PROTO questions
/*
Best way to model map<string, interface?>
Best way to support generic error handling
And response duration time tracking
Auth headers
 */

// TODO: how do we include a common error to all responses?
message Error {
  int64 Code = 1;
  string Description = 2;
  bytes Data = 3;
}

service CallCoordinatorService {
  // basic CRUD operations on calls
  rpc CreateCall(CreateCallRequest) returns (CreateCallResponse);
  rpc GetCall(GetCallRequest) returns (GetCallResponse);
  rpc UpdateCall(UpdateCallRequest) returns (UpdateCallResponse);
  rpc DeleteCall(DeleteCallRequest) returns (DeleteCallResponse);

  // join call
  rpc JoinCall(JoinCallRequest) returns (JoinCallResponse);
  rpc SelectEdgeServer(SelectEdgeServerRequest) returns(SelectEdgeServerResponse);
  rpc LeaveCall(LeaveCallRequest) returns (LeaveCallResponse);
  rpc EndCall(EndCallRequest) returns (EndCallResponse);

  // register mobile device for push
  rpc AddDevice(AddDeviceRequest) returns (AddDeviceResponse);
  rpc RemoveDevice(RemoveDeviceRequest) returns (RemoveDeviceResponse);
  rpc ListDevices(ListDevicesRequest) returns (ListDevicesResponse);

  // add reaction should perhaps just be handled by chat
  rpc SendCustomEvent(SendCustomEventRequest) returns (SendCustomEventResponse);

  // room is a confusing name. better to call it breakout room
  // breakout rooms have their own audio/video track
  // breakout rooms have their own chat
  /**
  TODO
  rpc CreateBreakoutRoom(CreateBreakoutRoomRequest) returns (CreateBreakoutRoomResponse);
  rpc JoinBreakoutRoom() returns ();
  rpc LeaveBreakoutRoom() returns ();
  rpc DeleteBreakoutRoom() returns ();
  */

  // server side sync & advanced endpoints
  rpc CreateOrUpdateCalls(CreateOrUpdateCallsRequest) returns (CreateOrUpdateCallsResponse);
  rpc CreateOrUpdateUsers(CreateOrUpdateUsersRequest) returns (CreateOrUpdateUsersResponse);

  // recording a call or transcribing a call can be
  // A. Enabled by default for a call type
  // B. Enabled when creating the call per the default call type settings
  // C. Configured differently for that specific call
  // D. Enabled during the call
  rpc TranscribeCall(TranscribeCallRequest) returns (TranscribeCallResponse);
  rpc StopTranscribeCall(StopTranscribeCallRequest) returns (StopTranscribeCallResponse);

  // start broadcast/ stop broadcast to HLS, RTMP and storage
  rpc StartBroadcast(StartBroadcastRequest) returns (StartBroadcastResponse);
  rpc StopBroadcast(StopBroadcastRequest) returns (StartBroadcastResponse);

  // User & GDPR endpoints, delete user
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
  rpc DeleteUser(DeleteUserRequest) returns (DeleteUserResponse);
  rpc ExportUser(ExportUserRequest) returns (ExportUserResponse);
  // This requires having some sort of user/team level concept

  // call recording endpoints
  rpc StartRecording(StartRecordingRequest) returns (StartRecordingResponse);
  rpc StopRecording(StopRecordingRequest) returns (StopRecordingResponse);
  rpc GetRecordings(GetRecordingsRequest) returns (GetRecordingsResponse);
}

message GetCallRequest {
  string ID = 1;
  string Type = 2;
}

message GetCallResponse {
  Call Call = 1;
  CallState CallState = 2;
}

message CreateOrUpdateCallsRequest {
  repeated CreateCallRequest calls = 1;
}

message CreateOrUpdateCallsResponse {
  repeated Call calls = 1;
}

message CreateCallRequest {
  string ID = 1;
  string Type = 2;
  bytes JSONEncodedCustomData = 3;
  repeated string Participants = 4;

  // TODO: additional options and overrides to default settings
  // enable broadcasting
  bool Broadcast = 6;
  repeated BroadcastOptions BroadcastOptions = 7;

  // enable transcription
  bool Transcribe = 8;
  TranscribeOptions TranscribeOptions = 9;

  bool Recording = 10;
  bool Ring = 11; // if true, will call/ring on the browser and phone. default is false
}

message CreateCallResponse {
  Call call = 1 [(validate.rules).message.required = true];
}

message UpdateCallRequest {
  string ID = 1;
  string Type = 2;
  bytes JSONEncodedCustomData = 3;
  string AuthToken = 4;
  // TODO: additional options and overrides to default settings
}
message UpdateCallResponse {
  Call call = 1;
}

message DeleteCallRequest {
  string ID = 1;
}
message DeleteCallResponse {
}

message SelectEdgeServerRequest {
  string CallID = 1;
  string UserID = 2;
  map<string, Latency> LatencyByEdge = 3;
}

message SelectEdgeServerResponse {
  EdgeServer EdgeServer = 1;
  string Token = 2; // this is the token livekit needs, not the same token
}

message AddDeviceRequest {
  string UserID = 1;
  string ID = 2;
  string PushProvider = 3;
  bool Disabled = 4;
  string DisabledReason = 5;
  string PushProviderName = 6;
}

message AddDeviceResponse {
}

message RemoveDeviceRequest {
  string ID = 1;
}

message RemoveDeviceResponse {
}

message ListDevicesRequest {
  string UserID = 1;
}

message ListDevicesResponse {
  repeated Device devices = 1;
}

message CreateUserRequest {
  string ID = 1;
}

message CreateOrUpdateUsersRequest {
  repeated CreateUserRequest users = 1;
}

message CreateOrUpdateUsersResponse {
  repeated User users = 1;
}

message DeleteUserRequest {
  string ID = 1;
}

// TODO: do we support both soft and hard delete
message ExportUserRequest {
  string ID = 1;
}

// TODO: talk about what data we should export on the GDPR endpoints for a user
message ExportUserResponse {
  string ID = 1;
}

message DeleteUserResponse {
  string ID = 1;
}

message CreateUserResponse {
  User user = 1;
}

message SendCustomEventRequest {
  string type = 1;
  bytes data = 2;
}

message SendCustomEventResponse {
}

message JoinCallRequest {
  string CallID = 1;
  string ClientIP = 2;
}

message UserCapability {
  string action = 1;
  string description = 2;
}

message JoinCallResponse {
  User user = 1;
  Call call = 2;
  CallState CallState = 3;
  repeated Edge Edges = 4;
  repeated UserCapability OwnCapabilities = 5;
}

message LeaveCallRequest {

}

message LeaveCallResponse {
}

message EndCallRequest {

}

message EndCallResponse {
}

message StartBroadcastRequest {
  string type = 1; // initially RTMP, record and HLS
  // TODO: understand what fields we need to track here
}

message StartBroadcastResponse {
}

message StopBroadcastRequest {
}

message StopBroadcastResponse {
}

message TranscribeCallRequest {
  // TODO: research what options we need here
}

message TranscribeCallResponse {
}

message StopTranscribeCallRequest {
}

message StopTranscribeCallResponse {
}

message StoreLatencyRequest {}

message StoreLatencyResponse {}

message StartRecordingRequest {
  string CallID = 1;
  RecordingStorageOptions StorageOptions = 2;
  Codec Codec = 3;
}

message StartRecordingResponse {}

message StopRecordingRequest {
  string CallID = 1;
}

message StopRecordingResponse {}

// TODO: how do we do filtering and pagination with proto?
// here we need to be able to filter, sort and limit by
// call id, call custom attribute, call creation time, call including a user, call by type
message GetRecordingsRequest {}

message GetRecordingsResponse {}
