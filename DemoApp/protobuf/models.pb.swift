// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: video_models/models.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Stream_Video_Codec: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case h264 // = 0
  case vp8 // = 1
  case vp9 // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .h264
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .h264
    case 1: self = .vp8
    case 2: self = .vp9
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .h264: return 0
    case .vp8: return 1
    case .vp9: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_Codec: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Codec] = [
    .h264,
    .vp8,
    .vp9,
  ]
}

#endif  // swift(>=4.2)

enum Stream_Video_RecordingStorage: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case s3 // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .s3
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .s3
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .s3: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_RecordingStorage: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_RecordingStorage] = [
    .s3,
  ]
}

#endif  // swift(>=4.2)

/// Edges are where we deploy video servers
struct Stream_Video_Edge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var latencyURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Edges are where we deploy video servers
struct Stream_Video_EdgeServer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Latency {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var measurements: [Float] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 3 different type of broadcast
struct Stream_Video_Broadcast {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var details: Stream_Video_Broadcast.OneOf_Details? = nil

  var rtmp: Stream_Video_RTMPBroadcast {
    get {
      if case .rtmp(let v)? = details {return v}
      return Stream_Video_RTMPBroadcast()
    }
    set {details = .rtmp(newValue)}
  }

  var hls: Stream_Video_HLSBroadcast {
    get {
      if case .hls(let v)? = details {return v}
      return Stream_Video_HLSBroadcast()
    }
    set {details = .hls(newValue)}
  }

  var record: Stream_Video_RecordBroadcast {
    get {
      if case .record(let v)? = details {return v}
      return Stream_Video_RecordBroadcast()
    }
    set {details = .record(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Details: Equatable {
    case rtmp(Stream_Video_RTMPBroadcast)
    case hls(Stream_Video_HLSBroadcast)
    case record(Stream_Video_RecordBroadcast)

  #if !swift(>=4.1)
    static func ==(lhs: Stream_Video_Broadcast.OneOf_Details, rhs: Stream_Video_Broadcast.OneOf_Details) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.rtmp, .rtmp): return {
        guard case .rtmp(let l) = lhs, case .rtmp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hls, .hls): return {
        guard case .hls(let l) = lhs, case .hls(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.record, .record): return {
        guard case .record(let l) = lhs, case .record(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Stream_Video_RTMPBroadcast {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var callID: String = String()

  var rtmpurls: [String] = []

  var width: Int32 = 0

  var height: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_HLSBroadcast {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_File {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var composite: Bool = false

  var userID: String = String()

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_RecordBroadcast {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// if true merge all audio and video, if false split them
  var composite: Bool = false

  var files: [Stream_Video_File] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  /// TODO: zoom allows you to invite any of your colleagues in their invite screen
  var teams: [String] = []

  var type: String = String()

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {self._updatedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Stream_Video_Device {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var id: String = String()

  var pushProvider: String = String()

  var disabled: Bool = false

  var disabledReason: String = String()

  var pushProviderName: String = String()

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {self._updatedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Stream_Video_RecordingStorageOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var storage: Stream_Video_RecordingStorage = .s3

  var accessKey: String = String()

  var secretKey: String = String()

  var bucketName: String = String()

  var region: String = String()

  var path: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_BroadcastOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rtmpURL: String = String()

  var hlsURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_TranscribeOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_CallType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var security: Stream_Video_Security {
    get {return _security ?? Stream_Video_Security()}
    set {_security = newValue}
  }
  /// Returns true if `security` has been explicitly set.
  var hasSecurity: Bool {return self._security != nil}
  /// Clears the value of `security`. Subsequent reads from it will return its default value.
  mutating func clearSecurity() {self._security = nil}

  /// enable broadcasting by default when creating a call of this type
  var broadcast: Bool = false

  var broadcastOptions: [Stream_Video_BroadcastOptions] = []

  /// enable transcription by default
  var transcribe: Bool = false

  var transcribeOptions: Stream_Video_TranscribeOptions {
    get {return _transcribeOptions ?? Stream_Video_TranscribeOptions()}
    set {_transcribeOptions = newValue}
  }
  /// Returns true if `transcribeOptions` has been explicitly set.
  var hasTranscribeOptions: Bool {return self._transcribeOptions != nil}
  /// Clears the value of `transcribeOptions`. Subsequent reads from it will return its default value.
  mutating func clearTranscribeOptions() {self._transcribeOptions = nil}

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {self._updatedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _security: Stream_Video_Security? = nil
  fileprivate var _transcribeOptions: Stream_Video_TranscribeOptions? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Stream_Video_Security {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hideProfilePictures: Bool = false

  var shareScreen: Stream_Video_Security.IsAllowed = .yes

  var renameUser: Bool = false

  var unmute: Stream_Video_Security.IsAllowed = .yes

  var startVideo: Stream_Video_Security.IsAllowed = .yes

  var screenShare: Stream_Video_Security.IsAllowed = .yes

  var record: Stream_Video_Security.IsAllowed = .yes

  var broadcast: Stream_Video_Security.IsAllowed = .yes

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// TODO this is actually one of the most complex UI things in zoom :)
  /// controls if regular users are allowed to do the following
  /// yes/no/request
  enum IsAllowed: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case yes // = 0
    case no // = 1
    case request // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .yes
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .yes
      case 1: self = .no
      case 2: self = .request
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .yes: return 0
      case .no: return 1
      case .request: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Stream_Video_Security.IsAllowed: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Security.IsAllowed] = [
    .yes,
    .no,
    .request,
  ]
}

#endif  // swift(>=4.2)

/// those who are online in the call
struct Stream_Video_Participant {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var role: String = String()

  var online: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_CallState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Little different to member/watcher concept. Both are in the participant list
  var callID: String = String()

  var participants: [Stream_Video_Participant] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Call {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var createdByUserID: String = String()

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {self._updatedAt = nil}

  /// enable broadcasting by default when creating a call of this type
  var broadcast: Bool = false

  var broadcastOptions: [Stream_Video_BroadcastOptions] = []

  /// enable transcription by default
  var transcribe: Bool = false

  var transcribeOptions: Stream_Video_TranscribeOptions {
    get {return _transcribeOptions ?? Stream_Video_TranscribeOptions()}
    set {_transcribeOptions = newValue}
  }
  /// Returns true if `transcribeOptions` has been explicitly set.
  var hasTranscribeOptions: Bool {return self._transcribeOptions != nil}
  /// Clears the value of `transcribeOptions`. Subsequent reads from it will return its default value.
  mutating func clearTranscribeOptions() {self._transcribeOptions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _transcribeOptions: Stream_Video_TranscribeOptions? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stream_Video_Codec: @unchecked Sendable {}
extension Stream_Video_RecordingStorage: @unchecked Sendable {}
extension Stream_Video_Edge: @unchecked Sendable {}
extension Stream_Video_EdgeServer: @unchecked Sendable {}
extension Stream_Video_Latency: @unchecked Sendable {}
extension Stream_Video_Broadcast: @unchecked Sendable {}
extension Stream_Video_Broadcast.OneOf_Details: @unchecked Sendable {}
extension Stream_Video_RTMPBroadcast: @unchecked Sendable {}
extension Stream_Video_HLSBroadcast: @unchecked Sendable {}
extension Stream_Video_File: @unchecked Sendable {}
extension Stream_Video_RecordBroadcast: @unchecked Sendable {}
extension Stream_Video_User: @unchecked Sendable {}
extension Stream_Video_Device: @unchecked Sendable {}
extension Stream_Video_RecordingStorageOptions: @unchecked Sendable {}
extension Stream_Video_BroadcastOptions: @unchecked Sendable {}
extension Stream_Video_TranscribeOptions: @unchecked Sendable {}
extension Stream_Video_CallType: @unchecked Sendable {}
extension Stream_Video_Security: @unchecked Sendable {}
extension Stream_Video_Security.IsAllowed: @unchecked Sendable {}
extension Stream_Video_Participant: @unchecked Sendable {}
extension Stream_Video_CallState: @unchecked Sendable {}
extension Stream_Video_Call: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stream.video"

extension Stream_Video_Codec: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "H264"),
    1: .same(proto: "VP8"),
    2: .same(proto: "VP9"),
  ]
}

extension Stream_Video_RecordingStorage: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "S3"),
  ]
}

extension Stream_Video_Edge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Edge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "LatencyURL"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.latencyURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.latencyURL.isEmpty {
      try visitor.visitSingularStringField(value: self.latencyURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Edge, rhs: Stream_Video_Edge) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.latencyURL != rhs.latencyURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_EdgeServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EdgeServer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_EdgeServer, rhs: Stream_Video_EdgeServer) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Latency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Latency"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "measurements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.measurements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.measurements.isEmpty {
      try visitor.visitPackedFloatField(value: self.measurements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Latency, rhs: Stream_Video_Latency) -> Bool {
    if lhs.measurements != rhs.measurements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Broadcast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Broadcast"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "rtmp"),
    3: .same(proto: "hls"),
    4: .same(proto: "record"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try {
        var v: Stream_Video_RTMPBroadcast?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .rtmp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .rtmp(v)
        }
      }()
      case 3: try {
        var v: Stream_Video_HLSBroadcast?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .hls(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .hls(v)
        }
      }()
      case 4: try {
        var v: Stream_Video_RecordBroadcast?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .record(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .record(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    switch self.details {
    case .rtmp?: try {
      guard case .rtmp(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .hls?: try {
      guard case .hls(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .record?: try {
      guard case .record(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Broadcast, rhs: Stream_Video_Broadcast) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_RTMPBroadcast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RTMPBroadcast"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CallID"),
    2: .same(proto: "RTMPUrls"),
    3: .same(proto: "Width"),
    4: .same(proto: "Height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.rtmpurls) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if !self.rtmpurls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.rtmpurls, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_RTMPBroadcast, rhs: Stream_Video_RTMPBroadcast) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.rtmpurls != rhs.rtmpurls {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_HLSBroadcast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HLSBroadcast"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_HLSBroadcast, rhs: Stream_Video_HLSBroadcast) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".File"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Type"),
    2: .same(proto: "Composite"),
    3: .same(proto: "UserID"),
    4: .same(proto: "URL"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.composite) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.composite != false {
      try visitor.visitSingularBoolField(value: self.composite, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_File, rhs: Stream_Video_File) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.composite != rhs.composite {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_RecordBroadcast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordBroadcast"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Composite"),
    2: .same(proto: "Files"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.composite) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.files) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.composite != false {
      try visitor.visitSingularBoolField(value: self.composite, fieldNumber: 1)
    }
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_RecordBroadcast, rhs: Stream_Video_RecordBroadcast) -> Bool {
    if lhs.composite != rhs.composite {return false}
    if lhs.files != rhs.files {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "Teams"),
    3: .same(proto: "Type"),
    7: .same(proto: "CreatedAt"),
    8: .same(proto: "UpdatedAt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.teams) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.teams.isEmpty {
      try visitor.visitRepeatedStringField(value: self.teams, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_User, rhs: Stream_Video_User) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.teams != rhs.teams {return false}
    if lhs.type != rhs.type {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Device"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UserID"),
    2: .same(proto: "ID"),
    3: .same(proto: "PushProvider"),
    4: .same(proto: "Disabled"),
    5: .same(proto: "DisabledReason"),
    6: .same(proto: "PushProviderName"),
    7: .same(proto: "CreatedAt"),
    8: .same(proto: "UpdatedAt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pushProvider) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.disabledReason) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.pushProviderName) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.pushProvider.isEmpty {
      try visitor.visitSingularStringField(value: self.pushProvider, fieldNumber: 3)
    }
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 4)
    }
    if !self.disabledReason.isEmpty {
      try visitor.visitSingularStringField(value: self.disabledReason, fieldNumber: 5)
    }
    if !self.pushProviderName.isEmpty {
      try visitor.visitSingularStringField(value: self.pushProviderName, fieldNumber: 6)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Device, rhs: Stream_Video_Device) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.pushProvider != rhs.pushProvider {return false}
    if lhs.disabled != rhs.disabled {return false}
    if lhs.disabledReason != rhs.disabledReason {return false}
    if lhs.pushProviderName != rhs.pushProviderName {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_RecordingStorageOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordingStorageOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "Storage"),
    3: .same(proto: "AccessKey"),
    4: .same(proto: "SecretKey"),
    5: .same(proto: "BucketName"),
    6: .same(proto: "Region"),
    7: .same(proto: "Path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularEnumField(value: &self.storage) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.accessKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.secretKey) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.bucketName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storage != .s3 {
      try visitor.visitSingularEnumField(value: self.storage, fieldNumber: 2)
    }
    if !self.accessKey.isEmpty {
      try visitor.visitSingularStringField(value: self.accessKey, fieldNumber: 3)
    }
    if !self.secretKey.isEmpty {
      try visitor.visitSingularStringField(value: self.secretKey, fieldNumber: 4)
    }
    if !self.bucketName.isEmpty {
      try visitor.visitSingularStringField(value: self.bucketName, fieldNumber: 5)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 6)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_RecordingStorageOptions, rhs: Stream_Video_RecordingStorageOptions) -> Bool {
    if lhs.storage != rhs.storage {return false}
    if lhs.accessKey != rhs.accessKey {return false}
    if lhs.secretKey != rhs.secretKey {return false}
    if lhs.bucketName != rhs.bucketName {return false}
    if lhs.region != rhs.region {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_BroadcastOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BroadcastOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RtmpURL"),
    2: .same(proto: "HlsUrl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rtmpURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hlsURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rtmpURL.isEmpty {
      try visitor.visitSingularStringField(value: self.rtmpURL, fieldNumber: 1)
    }
    if !self.hlsURL.isEmpty {
      try visitor.visitSingularStringField(value: self.hlsURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_BroadcastOptions, rhs: Stream_Video_BroadcastOptions) -> Bool {
    if lhs.rtmpURL != rhs.rtmpURL {return false}
    if lhs.hlsURL != rhs.hlsURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_TranscribeOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TranscribeOptions"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_TranscribeOptions, rhs: Stream_Video_TranscribeOptions) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_CallType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Security"),
    3: .same(proto: "Broadcast"),
    4: .same(proto: "BroadcastOptions"),
    5: .same(proto: "Transcribe"),
    6: .same(proto: "TranscribeOptions"),
    7: .same(proto: "CreatedAt"),
    8: .same(proto: "UpdatedAt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._security) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.broadcast) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.broadcastOptions) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.transcribe) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._transcribeOptions) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._security {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.broadcast != false {
      try visitor.visitSingularBoolField(value: self.broadcast, fieldNumber: 3)
    }
    if !self.broadcastOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.broadcastOptions, fieldNumber: 4)
    }
    if self.transcribe != false {
      try visitor.visitSingularBoolField(value: self.transcribe, fieldNumber: 5)
    }
    try { if let v = self._transcribeOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_CallType, rhs: Stream_Video_CallType) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._security != rhs._security {return false}
    if lhs.broadcast != rhs.broadcast {return false}
    if lhs.broadcastOptions != rhs.broadcastOptions {return false}
    if lhs.transcribe != rhs.transcribe {return false}
    if lhs._transcribeOptions != rhs._transcribeOptions {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Security: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Security"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HideProfilePictures"),
    2: .same(proto: "ShareScreen"),
    3: .same(proto: "RenameUser"),
    4: .same(proto: "Unmute"),
    5: .same(proto: "StartVideo"),
    6: .same(proto: "ScreenShare"),
    7: .same(proto: "Record"),
    8: .same(proto: "Broadcast"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.hideProfilePictures) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.shareScreen) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.renameUser) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.unmute) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.startVideo) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.screenShare) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.record) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.broadcast) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hideProfilePictures != false {
      try visitor.visitSingularBoolField(value: self.hideProfilePictures, fieldNumber: 1)
    }
    if self.shareScreen != .yes {
      try visitor.visitSingularEnumField(value: self.shareScreen, fieldNumber: 2)
    }
    if self.renameUser != false {
      try visitor.visitSingularBoolField(value: self.renameUser, fieldNumber: 3)
    }
    if self.unmute != .yes {
      try visitor.visitSingularEnumField(value: self.unmute, fieldNumber: 4)
    }
    if self.startVideo != .yes {
      try visitor.visitSingularEnumField(value: self.startVideo, fieldNumber: 5)
    }
    if self.screenShare != .yes {
      try visitor.visitSingularEnumField(value: self.screenShare, fieldNumber: 6)
    }
    if self.record != .yes {
      try visitor.visitSingularEnumField(value: self.record, fieldNumber: 7)
    }
    if self.broadcast != .yes {
      try visitor.visitSingularEnumField(value: self.broadcast, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Security, rhs: Stream_Video_Security) -> Bool {
    if lhs.hideProfilePictures != rhs.hideProfilePictures {return false}
    if lhs.shareScreen != rhs.shareScreen {return false}
    if lhs.renameUser != rhs.renameUser {return false}
    if lhs.unmute != rhs.unmute {return false}
    if lhs.startVideo != rhs.startVideo {return false}
    if lhs.screenShare != rhs.screenShare {return false}
    if lhs.record != rhs.record {return false}
    if lhs.broadcast != rhs.broadcast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Security.IsAllowed: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "YES"),
    1: .same(proto: "NO"),
    2: .same(proto: "REQUEST"),
  ]
}

extension Stream_Video_Participant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Participant"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UserID"),
    2: .same(proto: "Role"),
    3: .same(proto: "Online"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.online) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 2)
    }
    if self.online != false {
      try visitor.visitSingularBoolField(value: self.online, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Participant, rhs: Stream_Video_Participant) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.role != rhs.role {return false}
    if lhs.online != rhs.online {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_CallState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CallId"),
    2: .same(proto: "Participants"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.participants) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if !self.participants.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.participants, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_CallState, rhs: Stream_Video_CallState) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.participants != rhs.participants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Call: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Call"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "Name"),
    3: .same(proto: "CreatedByUserID"),
    4: .same(proto: "CreatedAt"),
    5: .same(proto: "UpdatedAt"),
    6: .same(proto: "Broadcast"),
    7: .same(proto: "BroadcastOptions"),
    8: .same(proto: "Transcribe"),
    9: .same(proto: "TranscribeOptions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.createdByUserID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.broadcast) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.broadcastOptions) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.transcribe) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._transcribeOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.createdByUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.createdByUserID, fieldNumber: 3)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.broadcast != false {
      try visitor.visitSingularBoolField(value: self.broadcast, fieldNumber: 6)
    }
    if !self.broadcastOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.broadcastOptions, fieldNumber: 7)
    }
    if self.transcribe != false {
      try visitor.visitSingularBoolField(value: self.transcribe, fieldNumber: 8)
    }
    try { if let v = self._transcribeOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Call, rhs: Stream_Video_Call) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.createdByUserID != rhs.createdByUserID {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.broadcast != rhs.broadcast {return false}
    if lhs.broadcastOptions != rhs.broadcastOptions {return false}
    if lhs.transcribe != rhs.transcribe {return false}
    if lhs._transcribeOptions != rhs._transcribeOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
